<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h4 class="heading"><span class="type">Paragraph</span></h4>
<div class="para logical">
<div class="para">When dealing with artificial languages such as programming languages, itâ€™s better to avoid ambiguity. The grammar <span class="process-math">\(G_1\)</span> is perfectly correct in that it generates the correct set of strings, but in a practical situation where we are interested in the meaning of the strings, <span class="process-math">\(G_1\)</span> is not the right grammar for the job.  There are other grammars that generate the same language as <span class="process-math">\(G_1\text{.}\)</span>  Some of them are unambiguous grammars that better reflect the meaning of the strings in the language.  For example, the language <span class="process-math">\(L(G_1)\)</span> is also generated by the BNF grammar</div>
<div class="displaymath process-math">
\begin{align*}
E \amp ::= T\ [\ +\ T\ ]\dots\\
T  \amp ::= F\ [\ *\ F\ ]\dots\\
F \amp ::= \text{}\ E\ \text{}\ \BNFALT\ x\ \BNFALT\ y\ \BNFALT\ z
\end{align*}
</div>
<div class="para">This grammar can be translated into a standard context-free grammar, which I will call <span class="process-math">\(G_2\text{:}\)</span>
</div>
<div class="displaymath process-math">
\begin{align*}
E \amp \PRODUCES TA\\
A \amp\PRODUCES +TA \\
A \amp \PRODUCES \EMPTYSTRING \\
T \amp \PRODUCES FB\\
B \amp \PRODUCES *FB\\
B \amp \PRODUCES \EMPTYSTRING \\
F \amp \PRODUCES (E)\\
F \amp \PRODUCES x\\
F \amp \PRODUCES y\\
F \amp \PRODUCES z
\end{align*}
</div>
<div class="para">The language generated by <span class="process-math">\(G_2\)</span> consists of all legal arithmetic expressions made up of parentheses, the operators <span class="process-math">\(+\)</span> and <span class="process-math">\(-\text{,}\)</span> and the variables <span class="process-math">\(x\text{,}\)</span> <span class="process-math">\(y\text{,}\)</span> and <span class="process-math">\(z\text{.}\)</span>  That is, <span class="process-math">\(L(G_2)=L(G_1)\text{.}\)</span>  However, <span class="process-math">\(G_2\)</span> is an unambiguous grammar.  Consider, for example, the string <span class="process-math">\(x+y*z\text{.}\)</span>  Using the grammar <span class="process-math">\(G_2\text{,}\)</span> the only left derivation for this string is:</div>
<div class="displaymath process-math">
\begin{align*}
E \amp \YIELDS TA\\
\amp \YIELDS FBA\\
\amp \YIELDS xBA\\
\amp \YIELDS xA\\
\amp \YIELDS x+TA\\
\amp \YIELDS x+FBA\\
\amp \YIELDS x+yBA\\
\amp \YIELDS x+y*FBA\\
\amp \YIELDS x+y*zBA\\
\amp \YIELDS x+y*zA\\
\amp \YIELDS x+y*z
\end{align*}
</div>
<div class="para">There is no choice about the first step in this derivation, since the only production rule with <span class="process-math">\(E\)</span> on the left-hand side is <span class="process-math">\(E\PRODUCES TA\text{.}\)</span> Similarly, the second step is forced by the fact that there is only one rule for rewriting a <span class="process-math">\(T\text{.}\)</span>  In the third step, we must replace an <span class="process-math">\(F\text{.}\)</span>  There are four ways to rewrite <span class="process-math">\(F\text{,}\)</span> but only one way to produce the <span class="process-math">\(x\)</span> that begins the string <span class="process-math">\(x+y*z\text{,}\)</span> so we apply the rule <span class="process-math">\(F\PRODUCES x\text{.}\)</span> Now, we have to decide what to do with the <span class="process-math">\(B\)</span> in <span class="process-math">\(xBA\text{.}\)</span>  There two rules for rewriting <span class="process-math">\(B\text{,}\)</span> <span class="process-math">\(B\PRODUCES *FB\)</span> and <span class="process-math">\(B\PRODUCES\EMPTYSTRING\text{.}\)</span>  However, the first of these rules introduces a non-terminal, <span class="process-math">\(*\text{,}\)</span> which does not match the string we are trying to parse.  So, the only choice is to apply the production rule <span class="process-math">\(B\PRODUCES\EMPTYSTRING\text{.}\)</span>  In the next step of the derivation, we must apply the rule <span class="process-math">\(A\PRODUCES +TA\)</span> in order to account for the <span class="process-math">\(+\)</span> in the string <span class="process-math">\(x+y*z\text{.}\)</span>  Similarly, each of the remaining steps in the left derivation is forced.</div>
</div>
<span class="incontext"><a href="sec-grammars.html#p-5203" class="internal">in-context</a></span>
</body>
</html>
