<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="theorem theorem-like"><h4 class="heading">
<span class="type">Theorem</span><span xmlns:xlink="http://www.w3.org/1999/xlink" class="space"> </span><span class="codenumber">17.4.1</span><span xmlns:xlink="http://www.w3.org/1999/xlink" class="period">.</span>
</h4>
<div xmlns:xlink="http://www.w3.org/1999/xlink" class="para">Every language generated by a regular expression can be recognized by an NFA.</div></article><details xmlns:xlink="http://www.w3.org/1999/xlink" class="hiddenproof born-hidden-knowl"><summary class="knowl__link"><h4 class="heading"><span class="type">Proof<span class="period">.</span></span></h4></summary><article class="hiddenproof knowl__content"><div class="para">The proof of this theorem is a nice example of a proof by induction on the structure of regular expressions. The definition of regular expression is inductive: <span class="process-math">\(\Phi\)</span> , <span class="process-math">\(\varep\text{,}\)</span> and <span class="process-math">\(a\)</span> are the simplest regular expressions, and then more complicated regular expressions can be built from these. We will show that there are NFAs that accept the languages generated by the simplest regular expressions, and then show how those machines can be put together to form machines that accept languages generated by more complicated regular expressions. Consider the regular expression <span class="process-math">\(\Phi\text{.}\)</span> <span class="process-math">\(L(\Phi) = \{\}\text{.}\)</span> Here is a machine that accepts <span class="process-math">\(\{\}\text{:}\)</span> <figure class="figure figure-like"><div class="image-box" style="width: 80%; margin-left: 10%; margin-right: 10%;"><img src="external/images/fsa12.svg" role="img" class="contained" alt="Diagram of an NFA that accepts \(L(\Phi) = \{\}\text{.}\)"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">17.4.2<span class="period">.</span></span><span class="space"> </span></figcaption></figure>
</div>
<div class="para">Consider the regular expression <span class="process-math">\(\varep\text{.}\)</span> <span class="process-math">\(L(\varep) = \{\varepsilon\}\text{.}\)</span> Here is a machine that accepts <span class="process-math">\(\{\varepsilon\}\text{:}\)</span> <figure class="figure figure-like"><div class="image-box" style="width: 80%; margin-left: 10%; margin-right: 10%;"><img src="external/images/fsa13.svg" role="img" class="contained" alt="Diagram of an NFA that accepts \(L(\varep) = \{\varepsilon\}\text{.}\)"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">17.4.3<span class="period">.</span></span><span class="space"> </span></figcaption></figure>
</div>
<div class="para">Consider the regular expression <span class="process-math">\(a\text{.}\)</span> <span class="process-math">\(L(a) = \{a\}\text{.}\)</span> Here is a machine that accepts <span class="process-math">\(\{a\}\text{:}\)</span> <figure class="figure figure-like"><div class="image-box" style="width: 80%; margin-left: 10%; margin-right: 10%;"><img src="external/images/fsa14.svg" role="img" class="contained" alt="Diagram of an NFA that accepts \(L(a) = \{a\}\text{.}\)"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">17.4.4<span class="period">.</span></span><span class="space"> </span></figcaption></figure>
</div>
<div class="para">Now suppose that you have NFAs that accept the languages generated by the regular expressions <span class="process-math">\(r_1\)</span> and <span class="process-math">\(r_2\text{.}\)</span> Building a machine that accepts <span class="process-math">\(L(r_1 \REOR r_2)\)</span> is fairly straightforward: take an NFA <span class="process-math">\(M_1\)</span> that accepts <span class="process-math">\(L(r_1)\)</span> and an NFA <span class="process-math">\(M_2\)</span> that accepts <span class="process-math">\(L(r_2)\text{.}\)</span> Introduce a new state <span class="process-math">\(q_{new}\text{,}\)</span> connect it to the start states of <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\)</span> via <span class="process-math">\(\varepsilon\)</span>-transitions, and designate it as the start state of the new machine. No other transitions are added. The final states of <span class="process-math">\(M_1\)</span> together with the final states of <span class="process-math">\(M_2\)</span> are designated as the final states of the new machine. It should be fairly clear that this new machine accepts exactly those strings accepted by <span class="process-math">\(M_1\)</span> together with those strings accepted by <span class="process-math">\(M_2\text{:}\)</span> any string <span class="process-math">\(w\)</span> that was accepted by <span class="process-math">\(M_1\)</span> will be accepted by the new NFA by starting with an <span class="process-math">\(\varep\)</span>-transition to the old start state of <span class="process-math">\(M_1\)</span> and then following the accepting path through <span class="process-math">\(M_1\text{;}\)</span> similarly, any string accepted by <span class="process-math">\(M_2\)</span> will be accepted by the new machine; these are the only strings that will be accepted by the new machine, as on any input <span class="process-math">\(w\)</span> all the new machine can do is make an <span class="process-math">\(\varep\)</span>-move to <span class="process-math">\(M_1\)</span>’s (or <span class="process-math">\(M_2\)</span>’s) start state, and from there <span class="process-math">\(w\)</span> will only be accepted by the new machine if it is accepted by <span class="process-math">\(M_1\)</span> (or <span class="process-math">\(M_2\)</span>). Thus, the new machine accepts <span class="process-math">\(L(M_1) \cup L(M_2)\text{,}\)</span> which is <span class="process-math">\(L(r_1) \cup L(r_2)\text{,}\)</span> which is exactly the definition of <span class="process-math">\(L(r_1 \REOR r_2)\text{.}\)</span> <figure class="figure figure-like"><div class="image-box" style="width: 80%; margin-left: 10%; margin-right: 10%;"><img src="external/images/fsa15.svg" role="img" class="contained" alt="Diagram of an NFA that accepts \(L(r_1 \REOR r_2)\text{.}\)"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">17.4.5<span class="period">.</span></span><span class="space"> </span></figcaption></figure>
</div>
<article class="remark remark-like"><h5 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">17.4.6</span><span class="period">.</span><span class="space"> </span><span class="title">A pause before we continue:.</span>
</h5>
<div class="para">Note that for the simplest regular expressions, the machines that we created to accept the languages generated by the regular expressions were in fact DFAs. In our last case above, however, we needed <span class="process-math">\(\varep\)</span>-transitions to build the new machine, and so if we were trying to prove that every regular language could be accepted by a DFA, our proof would be in trouble. THIS DOES NOT MEAN that the statement ``every regular language can be accepted by a DFA" is false, just that we can’t prove it using this kind of argument, and would have to find an alternative proof.</div></article><div class="para">Suppose you have machines <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\)</span> that accept <span class="process-math">\(L(r_1)\)</span> and <span class="process-math">\(L(r_2)\)</span> respectively. To build a machine that accepts <span class="process-math">\(L(r_1)L(r_2)\)</span> proceed as follows. Make the start state <span class="process-math">\(q_{01}\)</span> of <span class="process-math">\(M_1\)</span> be the start state of the new machine. Make the final states of <span class="process-math">\(M_2\)</span> be the final states of the new machine. Add <span class="process-math">\(\varep\)</span>-transitions from the final states of <span class="process-math">\(M_1\)</span> to the start state <span class="process-math">\(q_{02}\)</span> of <span class="process-math">\(M_2\text{.}\)</span> <figure class="figure figure-like"><div class="image-box" style="width: 80%; margin-left: 10%; margin-right: 10%;"><img src="external/images/fsa16.svg" role="img" class="contained" alt="Diagram of an NFA that accepts \(L(r_1)L(r_2)\text{.}\)"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">17.4.7<span class="period">.</span></span><span class="space"> </span></figcaption></figure>
</div>
<div class="para">It should be fairly clear that this new machine accepts exactly those strings of the form <span class="process-math">\(xy\)</span> where <span class="process-math">\(x\in L(r_1)\)</span> and <span class="process-math">\(y \in L(r_2)\text{:}\)</span> first of all, any string of this form will be accepted because <span class="process-math">\(x\in L(r_1)\)</span> implies there is a path that consumes <span class="process-math">\(x\)</span> from <span class="process-math">\(q_{01}\)</span> to a final state of <span class="process-math">\(M_1\text{;}\)</span> a <span class="process-math">\(\varep\)</span>-transition moves to <span class="process-math">\(q_{02}\text{;}\)</span> then <span class="process-math">\(y \in L(r_2)\)</span> implies there is a path that consumes <span class="process-math">\(y\)</span> from <span class="process-math">\(q_{02}\)</span> to a final state of <span class="process-math">\(M_2\text{;}\)</span> and the final states of <span class="process-math">\(M_2\)</span> are the final states of the new machine, so <span class="process-math">\(xy\)</span> will be accepted. Conversely, suppose <span class="process-math">\(z\)</span> is accepted by the new machine. Since the only final states of the new machine are in the old <span class="process-math">\(M_2\text{,}\)</span> and the only way to get into <span class="process-math">\(M_2\)</span> is to take a <span class="process-math">\(\varep\)</span>-transition from a final state of <span class="process-math">\(M_1\text{,}\)</span> this means that <span class="process-math">\(z=xy\)</span> where <span class="process-math">\(x\)</span> takes the machine from its start state to a final state of <span class="process-math">\(M_1\text{,}\)</span> a <span class="process-math">\(\varep\)</span>-transition occurs, and then <span class="process-math">\(y\)</span> takes the machine from <span class="process-math">\(q_{02}\)</span> to a final state of <span class="process-math">\(M_2\text{.}\)</span> Clearly, <span class="process-math">\(x\in L(r_1)\)</span> and <span class="process-math">\(y \in L(r_2)\text{.}\)</span>
</div>
<div class="para">We leave the construction of an NFA that accepts <span class="process-math">\(L(r^*)\)</span> from an NFA that accepts <span class="process-math">\(L(r)\)</span> as an exercise.</div></article></details><span class="incontext"><a class="internal" href="sec-FSA-and-Regular-Languages.html#thm-reg-lang-recog-by-nfa">in-context</a></span>
</body>
</html>
