<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>// Make *any* pre with class 'sagecell-sage' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({
  "inputLocation": "pre.sagecell-sage",
  "linked": true,
  "linkKey": "linked-sage",
  "autoeval": false,
  "languages": [
    "sage"
  ],
  "evalButtonText": "Evaluate (Sage)"
});
</script>
</head>
<body class="ignore-math">
<section class="paragraphs"><h5 class="heading"><span class="title">Binary Search.</span></h5>
<div class="para">The binary search algorithm is a much more efficient way to search for an item in a list than linear search, however, the list to be searched must be put into a sorted order before searching can be done. Binary search is an example of a “divide-and-conquer” algorithm where the problem is repeatedly divided into smaller problems until solving the problem is very easy. We will come back to see the recursive version of Binary Search in <a href="section9_2-Recursive_Algorithms.html" class="internal" title="Section 9.2: Recursive Algorithms">Section 9.2</a> on recursive algorithms. Here we describe the <em class="emphasis">iterative</em>, or looping, version.</div> <div class="para">The binary search algorithm starts by comparing the item in the middle position of the sorted list to the target. If the middle item is the same as the target item, then the location is returned. If the target is larger than the middle item, the lower half of the list is disregarded, the middle becomes the new start of the list and the target is compared to the item halfway between the new start and the end. If the target is smaller than the middle item, the upper half of the list is disregarded, the middle becomes the new end of the list, and the target is compared to the item halfway between the beginning and the new end. This procedure continues until the target is found or the list is reduced to a single item and that doesn’t match the target.</div> <div class="para"><article class="algorithm theorem-like"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">9.1.12</span><span class="period">.</span><span class="space"> </span><span class="title">Iterative Binary Search.</span>
</h6>
<section class="paragraphs"><h6 class="heading"><span class="title">procedure binary search.</span></h6> <div class="para">(<span class="process-math">\(x\text{:}\)</span> target; <span class="process-math">\(\{a_1, a_2, ..., a_n\}\text{:}\)</span> sorted list of items)</div> <div class="tabular-box natural-width"><table class="tabular">
<tr><td class="l m b0 r0 l0 t0 lines" colspan="3">loc := -1</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines" colspan="3">begin := 1</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines" colspan="3">end := n</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines" colspan="3">found := FALSE</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines" colspan="3">
<em class="alert">while</em> (begin <span class="process-math">\(\leq\)</span> end) and (not found)</td></tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines" colspan="2">mid := (begin + end) / 2</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines" colspan="2">
<em class="alert">if</em> <span class="process-math">\(x = a_{mid}\)</span>
</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines">
<em class="alert">then</em>  loc := mid</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines">found := TRUE</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines" colspan="2">
<em class="alert">else if</em>  <span class="process-math">\(x &lt; a_{mid}\)</span>
</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines">
<em class="alert">then</em> end := mid - 1</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines"><em class="alert">else</em></td>
<td class="l m b0 r0 l0 t0 lines"></td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines">begin := mid + 1</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines">
<em class="alert">return</em> loc</td>
<td class="l m b0 r0 l0 t0 lines"></td>
<td class="l m b0 r0 l0 t0 lines"></td>
</tr>
</table></div></section></article></div> <div class="para">In the following implementation of the Iterative Binary Search in SageMath, we search within a sorted list of integers.</div> <pre id="sage-22" class="ptx-sagecell sagecell-sage"><script type="text/x-sage">def IterativeBinarySearch(target, aList):
  loc = -1
  begin = 0
  end = len(aList) - 1
  mid = -1
  found = False

  while (begin <= end) and (not found):

    mid = floor((begin + end)/2)
    print('comparing with item in position '+str(mid))
    if aList[mid] == target:
      loc = mid
      found = True
      print('found in position '+str(loc))
    elif aList[mid] > target:
        end = mid - 1
        print('target is less than: ' + str(aList[mid]))
    else:
        begin = mid + 1
        print('target is greater than: ' + str(aList[mid]))

  return loc
s=[1,9,13,16,30,31,32,33,36,37,38,45,49,50,52,61,63,64,69,77,79,80,81,83,86,90,93,96]
IterativeBinarySearch(37, s)
</script></pre></section><span class="incontext"><a class="internal" href="section9_1-Algorithms.html#paragraphs-8">in-context</a></span>
</body>
</html>
