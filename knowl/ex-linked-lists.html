<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="example example-like"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">11.6.9</span><span class="period">.</span><span class="space"> </span><span class="title">Linked Lists using a Direct Product.</span>
</h4> <div class="para logical">
<div class="para">Using the identity <span class="process-math">\((x + y) + x = y\text{,}\)</span> in <span class="process-math">\(\mathbb{Z}_2\text{,}\)</span> we can devise a scheme for representing a doubly linked list using only one link field. A doubly linked list is a list in which each node contains a pointer to its immediate successor and its immediate predecessor (see <a href="" class="xref" data-knowl="./knowl/fig-linked-list.html" title="Figure 11.6.10">Figure 11.6.10</a>). If the pointers are <span class="process-math">\(n\)</span>-digit binary addresses, then each pointer can be taken as an element of <span class="process-math">\(\mathbb{Z}_2{}^n\text{.}\)</span> Lists of this type can be accomplished using cells with only one link. In place of a left and a right pointer, the only “link” is the value of the sum (left link) + (right link). All standard list operations (merge, insert, delete, traverse, and so on) are possible with this structure, provided that you know the value of the nil pointer and the address, <span class="process-math">\(f\text{,}\)</span> of the first (i. e., leftmost) cell. Since first <span class="process-math">\(f.\textrm{
left}\)</span> is nil, we can recover <span class="process-math">\(f.\textrm{ right}\)</span> by adding the value of nil: <span class="process-math">\(f + \textrm{ nil} = (\textrm{ nil} + f.\textrm{right}) + \textrm{nil} =
f.\textrm{right}\text{,}\)</span> which is the address of the second item. Now if we temporarily retain the address, <span class="process-math">\(s\text{,}\)</span> of the second cell, we can recover the address of the third item. The link field of the second item contains the sum <span class="process-math">\(s.\textrm{ left} +
s.\textrm{ right} = \textrm{ first} + \textrm{ third}\text{.}\)</span> Therefore</div>
<div class="displaymath process-math" data-contains-math-knowls="./knowl/fig-linked-list.html">
\begin{equation*}
\begin{split}
(\textrm{first} + \textrm{third})+ \textrm{first} &amp;= s + s.\textrm{left}\\
&amp;=( s.\textrm{left} + s.\textrm{right})+ s.\textrm{left}\\
&amp;=s.\textrm{right}\\
&amp;= \textrm{third}
\end{split}
\end{equation*}
</div>
</div> <div class="para">We no longer need the address of the first cell, only the second and third, to recover the fourth address, and so forth.</div> <figure class="figure figure-like"><div class="image-box" style="width: 70%; margin-left: 15%; margin-right: 15%;"><img src="external/images/fig-linked-list.png" class="contained" alt="Doubly Linked Lists"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">11.6.10<span class="period">.</span></span><span class="space"> </span>Doubly Linked Lists</figcaption></figure> <div class="para">The following more formal algorithm uses names that reflects the timing of the visits.</div> <div class="para">Given a doubly linked list, a traversal of the list is accomplished as follows, where <span class="process-math">\(\textit{first}\)</span> is the address of the first cell. We presume that each item has some information that is represented by <span class="process-math">\(\textrm{item}.\textrm{info}\)</span> and a field called item.link that is the sum of the left and right links.</div> <figure class="table table-like"><figcaption><span class="type">Table</span><span class="space"> </span><span class="codenumber">11.6.11<span class="period">.</span></span><span class="space"> </span></figcaption><div class="tabular-box natural-width"><table class="tabular">
<tr><td class="l m b0 r0 l0 t0 lines">(1) yesterday =nil</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines">(2) today =first</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines">(3)<span class="process-math">\(\quad \)</span>while <span class="process-math">\(\textrm{today} \neq \textrm{nil}\text{:}\)</span>
</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines">
<span class="process-math">\(\quad \quad \quad \)</span>(3.1)Write(today.info)</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines">
<span class="process-math">\(\quad \quad \quad \)</span>(3.2)tomorrow = today.link + yesterday</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines">
<span class="process-math">\(\quad \quad \quad \)</span>(3.3)yesterday = today</td></tr>
<tr><td class="l m b0 r0 l0 t0 lines">
<span class="process-math">\(\quad \quad \quad \)</span>(3.4)today = tomorrow.</td></tr>
</table></div></figure> <div class="para">At any point in this algorithm it would be quite easy to insert a cell between today and tomorrow. Can you describe how this would be accomplished?</div></article><span class="incontext"><a href="s-direct-products.html#ex-linked-lists" class="internal">in-context</a></span>
</body>
</html>
