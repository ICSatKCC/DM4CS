<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h4 class="heading"><span class="type">Paragraph</span></h4>
<div class="para">The second machine that we need will be called <span class="process-math">\(U\text{.}\)</span>  It is a so-called <dfn class="terminology">Universal Turing Machine</dfn>.  The single Turing machine <span class="process-math">\(U\)</span> can simulate the computation of any standard Turing machine, <span class="process-math">\(T\text{,}\)</span> on any input.  Both the symbolic representation of <span class="process-math">\(T\)</span> and that of the input string are written to <span class="process-math">\(U\)</span>’s tape, separated by a space.  As <span class="process-math">\(U\)</span> simulates the computation of <span class="process-math">\(T\text{,}\)</span> it will need some way to keep track of what state <span class="process-math">\(T\)</span> is in and of the position of <span class="process-math">\(T\)</span> on its (simulated) tape.  It does this by writing the current state of <span class="process-math">\(T\)</span> on its tape, following <span class="process-math">\(T\)</span>’s input string, and by adding a special symbol, such as <span class="process-math">\(@\text{,}\)</span> to the input string to mark <span class="process-math">\(T\)</span>’s position.  When <span class="process-math">\(U\)</span> is first started, it begins by adding the <span class="process-math">\(@\)</span>to the beginning of the input string and writing a <span class="process-math">\(q\)</span> after the string to represent the start state of <span class="process-math">\(T\text{.}\)</span>  It is then relatively straightforward for <span class="process-math">\(U\)</span> to simulate the computation of <span class="process-math">\(T\text{.}\)</span>  For each step in the computation of <span class="process-math">\(T\text{,}\)</span> it can determine the current state of <span class="process-math">\(T\)</span> (which is recorded on <span class="process-math">\(U\)</span>’s tape) and the symbol which <span class="process-math">\(T\)</span> is currently reading (which is on <span class="process-math">\(U\)</span>’s tape, after the <span class="process-math">\(@\)</span>). <span class="process-math">\(U\)</span> searches the symbolic representation of <span class="process-math">\(T\)</span> for the rule that tells <span class="process-math">\(T\)</span> what to do in this situation.  Using this rule, <span class="process-math">\(U\)</span> can update its representation of <span class="process-math">\(T\)</span>’s state, position, and tape to reflect the result of applying the rule. If the new state of <span class="process-math">\(T\)</span> is the halt state, then <span class="process-math">\(U\)</span> also halts. Otherwise, it goes on to simulate the next step in <span class="process-math">\(T\)</span>’s computation. Note that when <span class="process-math">\(U\)</span> is given <span class="process-math">\(T\)</span> and an input string <span class="process-math">\(w\)</span> as input, <span class="process-math">\(U\)</span> will halt if and only if <span class="process-math">\(T\)</span> halts on input <span class="process-math">\(w\text{.}\)</span> (Obviously, this is a very inefficient simulation, but we are not concerned with efficiency here.)</div>
<span class="incontext"><a href="sec-turing-machines-comp.html#p-5292" class="internal">in-context</a></span>
</body>
</html>
