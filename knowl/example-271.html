<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="example example-like"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">17.5.7</span><span class="period">.</span><span class="space"> </span><span class="title">Balanced Parentheses.</span>
</h4> <div class="para logical">
<div class="para">Closely related to this idea of matching <span class="process-math">\(a\text{'s}\)</span> and <span class="process-math">\(b\text{'s}\)</span> is the idea of <dfn class="terminology">balanced parentheses</dfn>. Consider a string made up of parentheses, such as <code class="code-inline tex2jax_ignore">(()(()))(())</code>. The parentheses in this sample string are balanced because each left parenthesis has a matching right parenthesis, and the matching pairs are properly nested. A careful definition uses the sort of integer sequence introduced in the above proof. Let <span class="process-math">\(w\)</span> be a string of parentheses. Write <span class="process-math">\(w=c_1c_2\cdots c_n\text{,}\)</span> where each <span class="process-math">\(c_i\)</span> is either <code class="code-inline tex2jax_ignore">(</code> or <code class="code-inline tex2jax_ignore">)</code>. Define a sequence of integers <span class="process-math">\(r_1\text{,}\)</span> <span class="process-math">\(r_2\text{,}\)</span> <span class="process-math">\(\dots\text{,}\)</span><span class="process-math">\(r_n\text{,}\)</span> where <span class="process-math">\(r_i\)</span> is the number of left parentheses in <span class="process-math">\(c_1c_2\cdots c_i\)</span> minus the number of right parentheses. We say that the parentheses in <span class="process-math">\(w\)</span> are balanced if <span class="process-math">\(r_n=0\)</span> and <span class="process-math">\(r_i\ge0\)</span> for all <span class="process-math">\(i=1,2,\dots,n\text{.}\)</span> The fact that <span class="process-math">\(r_n=0\)</span> says that <span class="process-math">\(w\)</span> contains the same number of left parentheses as right parentheses. The fact the <span class="process-math">\(r_i\ge0\)</span> means that the nesting of pairs of parentheses is correct: You can’t have a right parenthesis unless it is balanced by a left parenthesis in the preceding part of the string. The language that consists of all balanced strings of parentheses is context-free. It is generated by the grammar</div>
<div class="displaymath process-math">
\begin{align*}
S\amp\PRODUCES (\,S\,)\\
S\amp\PRODUCES SS \\
S\amp\PRODUCES \EMPTYSTRING 
\end{align*}
</div>
<div class="para">The proof is similar to the preceding proof about strings of <span class="process-math">\(a\text{'s}\)</span> and <span class="process-math">\(b\text{'s}\text{.}\)</span> (It might seem that I’ve made an awfully big fuss about matching and balancing. The reason is that this is one of the few things that we can do with context-free languages that we can’t do with regular languages.)</div>
</div></article><span class="incontext"><a class="internal" href="sec-grammars.html#example-271">in-context</a></span>
</body>
</html>
