<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h4 class="heading"><span class="type">Paragraph</span></h4>
<div class="para">We have already seen that if two languages <span class="process-math">\(L_1\)</span> and <span class="process-math">\(L_2\)</span> are regular, then so are <span class="process-math">\(L_1 \cup L_2\text{,}\)</span> <span class="process-math">\(L_1L_2\text{,}\)</span> and <span class="process-math">\(L_1^*\)</span> (and of course <span class="process-math">\(L_2^*\)</span>). We have not yet seen, however, how the common set operations intersection and complementation affect regularity. Is the complement of a regular language regular? How about the intersection of two regular languages? <div class="para"></div> Both of these questions can be answered by thinking of regular languages in terms of their acceptance by DFAs. Let’s consider first the question of complementation. Suppose we have an arbitrary regular language <span class="process-math">\(L\text{.}\)</span> We know there is a DFA <span class="process-math">\(M\)</span> that accepts <span class="process-math">\(L\text{.}\)</span> Pause a moment and try to think of a modification that you could make to <span class="process-math">\(M\)</span> that would produce a new machine <span class="process-math">\(M'\)</span> that accepts <span class="process-math">\(\overline{L}\text{....}\)</span> Okay, the obvious thing to try is to make <span class="process-math">\(M'\)</span> be a copy of <span class="process-math">\(M\)</span> with all final states of <span class="process-math">\(M\)</span> becoming non-final states of <span class="process-math">\(M'\)</span> and vice versa. This is in fact exactly right: <span class="process-math">\(M'\)</span> does in fact accept <span class="process-math">\(\overline{L}\text{.}\)</span> To verify this, consider an arbitrary string <span class="process-math">\(w\text{.}\)</span> The transition functions for the two machines <span class="process-math">\(M\)</span> and <span class="process-math">\(M'\)</span> are identical, so <span class="process-math">\(\delta^*
(q_0, w)\)</span> is the same state in both <span class="process-math">\(M\)</span> and <span class="process-math">\(M'\text{;}\)</span> if that state is accepting in <span class="process-math">\(M\)</span> then it is non-accepting in <span class="process-math">\(M'\text{,}\)</span> so if <span class="process-math">\(w\)</span> is accepted by <span class="process-math">\(M\)</span> it is not accepted by <span class="process-math">\(M'\text{;}\)</span> if the state is non-accepting in <span class="process-math">\(M\)</span> then it is accepting in <span class="process-math">\(M'\text{,}\)</span> so if <span class="process-math">\(w\)</span> is not accepted by <span class="process-math">\(M\)</span> then it is accepted by <span class="process-math">\(M'\text{.}\)</span> Thus <span class="process-math">\(M'\)</span> accepts exactly those strings that <span class="process-math">\(M\)</span> does not, and hence accepts <span class="process-math">\(\overline{L}\text{.}\)</span> <div class="para"></div> It is worth pausing for a moment and looking at the above argument a bit longer. Would the argument have worked if we had looked at an arbitrary language <span class="process-math">\(L\)</span> and an arbitrary NFA <span class="process-math">\(M\)</span> that accepted <span class="process-math">\(L\text{?}\)</span> That is, if we had built a new machine <span class="process-math">\(M'\)</span> in which the final and non-final states had been switched, would the new NFA <span class="process-math">\(M'\)</span> accept the complement of the language accepted by <span class="process-math">\(M\text{?}\)</span> The answer is ``not necessarily". Remember that acceptance in an NFA is determined based on whether or not at least one of the states reached by a string is accepting. So any string <span class="process-math">\(w\)</span> with the property that <span class="process-math">\(\partial^*(q_0,
w)\)</span> contains both accepting and non-accepting states of <span class="process-math">\(M\)</span> would be accepted both by <span class="process-math">\(M\)</span> and by <span class="process-math">\(M'\text{.}\)</span> <div class="para"></div> Now let’s turn to the question of intersection. Given two regular languages <span class="process-math">\(L_1\)</span> and <span class="process-math">\(L_2\text{,}\)</span> is <span class="process-math">\(L_1 \cap L_2\)</span> regular? Again, it is useful to think in terms of DFAs: given machines <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\)</span> that accept <span class="process-math">\(L_1\)</span> and <span class="process-math">\(L_2\text{,}\)</span> can you use them to build a new machine that accepts <span class="process-math">\(L_1 \cap L_2\text{?}\)</span> The answer is yes, and the idea behind the construction bears some resemblance to that behind the NFA-to-DFA construction. We want a new machine where transitions reflect the transitions of both <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\)</span> simultaneously, and we want to accept a string <span class="process-math">\(w\)</span> only if that those sequences of transitions lead to final states in both <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\text{.}\)</span> So we associate the states of our new machine <span class="process-math">\(M\)</span> with pairs of states from <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\text{.}\)</span> For each state <span class="process-math">\((q_1,q_2)\)</span> in the new machine and input symbol <span class="process-math">\(a\text{,}\)</span> define <span class="process-math">\(\delta((q_1,q_2),a)\)</span> to be the state <span class="process-math">\((\delta_1(q_1,a), \delta_2(q_2,a))\text{.}\)</span> The start state <span class="process-math">\(q_0\)</span> of <span class="process-math">\(M\)</span> is <span class="process-math">\((q_{01}, q_{02})\text{,}\)</span> where <span class="process-math">\(q_{0i}\)</span> is the start state of <span class="process-math">\(M_i\text{.}\)</span> The final states of <span class="process-math">\(M\)</span> are the the states of the form <span class="process-math">\((q_{f1},
q_{f2})\)</span> where <span class="process-math">\(q_{f1}\)</span> is an accepting state of <span class="process-math">\(M_1\)</span> and <span class="process-math">\(q_{f2}\)</span> is an accepting state of <span class="process-math">\(M_2\text{.}\)</span> You should convince yourself that <span class="process-math">\(M\)</span> accepts a string <span class="process-math">\(x\)</span> iff <span class="process-math">\(x\)</span> is accepted by both <span class="process-math">\(M_1\)</span> and <span class="process-math">\(M_2\text{.}\)</span> <div class="para"></div> The results of the previous section and the preceding discussion are summarized by the following theorem:</div>
<span class="incontext"><a href="sec-FSA-and-Regular-Languages.html#p-5080" class="internal">in-context</a></span>
</body>
</html>
