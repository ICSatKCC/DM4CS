<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="example example-like"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">9.3.6</span><span class="period">.</span><span class="space"> </span><span class="title">Complexity of the MergeSort Algorithm.</span>
</h4>  <div class="para">We now analyze the running time of algorithm <code class="code-inline tex2jax_ignore">MergeSort</code>, <a href="" class="xref" data-knowl="./knowl/alg-merge-sort.html" title="Algorithm 9.2.8: Merge Sort">Algorithm 9.2.8</a>. It follows from the pseudocode that, when running this algorithm together with its recursive calls, several calls are made to algorithm <code class="code-inline tex2jax_ignore">Merge</code>, <a href="" class="xref" data-knowl="./knowl/alg-merge.html" title="Algorithm 9.2.9: Merge">Algorithm 9.2.9</a>. What we need to count is the total number of comparisons that are made. That is, we will determine the total number of times that the line “if <span class="process-math">\(x \leq y\)</span>” in algorithm <code class="code-inline tex2jax_ignore">Merge</code> is executed when running algorithm <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code>.</div> <div class="para">We first observe that the number of comparisons made by algorithm <code class="code-inline tex2jax_ignore">Merge(L1,L2)</code> is at most <span class="process-math">\(|L_1|+|L_2|\text{.}\)</span>
</div> <div class="para">Let <span class="process-math">\(n\)</span> be an integer and assume for simplicity that <span class="process-math">\(n\)</span> is a power of two, i.e., <span class="process-math">\(n=2^k\)</span> for some integer <span class="process-math">\(k \geq 0\text{.}\)</span> We define <span class="process-math">\(T(n)\)</span> to be the maximum number of comparisons made when running algorithm <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code> on any input list <span class="process-math">\(L\)</span> of <span class="process-math">\(n\)</span> numbers. Note that we include in <span class="process-math">\(T(n)\)</span> all comparisons that are made during all calls to <code class="code-inline tex2jax_ignore">Merge</code> that are part of all recursive calls that are generated when running <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code>.</div> <div class="para logical">
<div class="para">Consider a list <span class="process-math">\(L\)</span> of <span class="process-math">\(n\)</span> numbers, where <span class="process-math">\(n\)</span> is a power of two. For <span class="process-math">\(n=1\text{,}\)</span> it follows from the pseudocode for <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code> that <em class="emphasis">T(1) = 0</em>. Assume that <span class="process-math">\(n \geq 2\)</span> and consider again the pseudocode for <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code>. Which parts of the algorithm make comparisons between input elements?</div>
<ul class="disc">
<li><div class="para">The call <code class="code-inline tex2jax_ignore">MergeSort(L1,m)</code> is a recursive call on a list of <span class="process-math">\(m=n/2\)</span> numbers. By definition, the total number of comparisons made in this call (together with all its recursive subcalls) is at most <span class="process-math">\(T(n/2)\text{.}\)</span>
</div></li>
<li><div class="para">The call <code class="code-inline tex2jax_ignore">MergeSort(L2,n-m)</code> is a recursive call on a list of <span class="process-math">\(n-m=n/2\)</span> numbers. By definition, the total number of comparisons made in this call (together with all its recursive subcalls) is at most <span class="process-math">\(T(n/2)\text{.}\)</span>
</div></li>
<li><div class="para">Finally, algorithm <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code> calls the non-recursive algorithm <code class="code-inline tex2jax_ignore">Merge(L1,L2)</code>. We have seen above that the number of comparisons made in this call is at most <span class="process-math">\(|L_1|+|L_2| = n\text{.}\)</span>
</div></li>
</ul>
</div> <div class="para logical">
<div class="para">By adding the number of comparisons, we get</div>
<div class="displaymath process-math">
\begin{equation*}
T(n) \leq T(n/2) + T(n/2) + n = 2 \cdot T(n/2) + n .
\end{equation*}
</div>
<div class="para">Thus, we obtain the following recurrence relation:</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{c c}
T(1)  &amp; =  0 , \nonumber \\
T(n)  &amp; \leq 2 \cdot T(n/2) + n \\
&amp;}
\end{array}
\end{equation*}
</div>
</div> <div class="para">Our goal was to determine <span class="process-math">\(T(n)\text{,}\)</span> but at this moment, we only have a recurrence relation for this function. We will solve this recurrence relation using a technique called unfolding:</div> <div class="para logical">
<div class="para">Recall that we assume that <span class="process-math">\(n=2^k\)</span> for some integer <span class="process-math">\(k \geq 0\text{.}\)</span> We furthermore assume that <span class="process-math">\(n\)</span> is a large integer. We know from above that</div>
<div class="displaymath process-math">
\begin{equation*}
T(n) \leq 2 \cdot T(n/2) + n .
\end{equation*}
</div>
<div class="para">If we replace <span class="process-math">\(n\)</span> by <span class="process-math">\(n/2\text{,}\)</span> which is a valid thing to do, we get</div>
<div class="displaymath process-math">
\begin{equation*}
T(n/2) \leq 2 \cdot T(n/2^2) + n/2 .
\end{equation*}
</div>
<div class="para">By combining these two inequalities, we get</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{c c c}
T(n)  &amp; \leq  &amp; 2 \cdot T(n/2) + n \\
&amp; \leq  &amp; 2 \left( 2 \cdot T(n/2^2) + n/2 \right) + n \\
&amp; =  &amp; 2^2 \cdot T(n/2^2) + 2n .
\end{array}
\end{equation*}
</div>
<div class="para">Let us repeat this: Replacing <span class="process-math">\(n\)</span> by <span class="process-math">\(n/2^2\)</span> the recurrence equation gives</div>
<div class="displaymath process-math">
\begin{equation*}
T(n/2^2) \leq 2 \cdot T(n/2^3) + n/2^2 .
\end{equation*}
</div>
<div class="para">By substituting this into the inequality for <span class="process-math">\(T(n)\text{,}\)</span> we get</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{c c c}
T(n)  &amp; \leq  &amp; 2^2 \cdot T(n/2^2) + 2n \\
&amp; \leq  &amp; 2^2 \left( 2 \cdot T(n/2^3) + n/2^2 \right) + 2n \\
&amp; =  &amp; 2^3 \cdot T(n/2^3) + 3n .
\end{array}
\end{equation*}
</div>
</div> <div class="para logical">
<div class="para">In the next step, we replace <span class="process-math">\(n\)</span> by <span class="process-math">\(n/2^3\)</span> in the recurrence equation, which gives</div>
<div class="displaymath process-math">
\begin{equation*}
T(n/2^3) \leq 2 \cdot T(n/2^4) + n/2^3 .
\end{equation*}
</div>
<div class="para">By substituting this into the inequality for <span class="process-math">\(T(n)\text{,}\)</span> we get</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{c c c}
T(n)  &amp; \leq  &amp; 2^3 \cdot T(n/2^3) + 3n \\
&amp; \leq  &amp; 2^3 \left( 2 \cdot T(n/2^4) + n/2^3 \right) + 3n \\
&amp; =  &amp; 2^4 \cdot T(n/2^4) + 4n .
\end{array}
\end{equation*}
</div>
</div> <div class="para logical">
<div class="para">At this moment, you will see the pattern and, at the end, we get the inequality</div>
<div class="displaymath process-math">
\begin{equation*}
T(n) \leq 2^k \cdot T(n/2^k) + kn .
\end{equation*}
</div>
<div class="para">Since <span class="process-math">\(n=2^k\text{,}\)</span> we have <span class="process-math">\(T(n/2^k) = T(1)\text{,}\)</span> which is <span class="process-math">\(0\)</span> from the base case of the recurrence relation. Also, <span class="process-math">\(n=2^k\)</span> implies that <span class="process-math">\(k = \log n\text{.}\)</span> We conclude that</div>
<div class="displaymath process-math">
\begin{equation*}
T(n) \leq n \cdot T(1) + n \log n = n \log n .
\end{equation*}
</div>
</div> <div class="para logical">
<div class="para">We thus have solved the recurrence relation. In case you have doubts about the validity of the unfolding method, we verify by induction that indeed</div>
<div class="displaymath process-math">
\begin{equation*}
T(n) \leq n \log n , n= 2^k.
\end{equation*}
</div>
<div class="para">The base case is when <span class="process-math">\(n=1\text{.}\)</span> In this case, we have <span class="process-math">\(T(1)=0\)</span> and <span class="process-math">\(1 \log 1 = 1 \cdot 0 = 0\text{.}\)</span> Let <span class="process-math">\(n \geq 2\)</span> be a power of <span class="process-math">\(2\)</span> and assume that</div>
<div class="displaymath process-math">
\begin{equation*}
T(n/2) \leq (n/2) \log (n/2) .
\end{equation*}
</div>
<div class="para">From the recurrence relation, we get</div>
<div class="displaymath process-math">
\begin{equation*}
T(n) \leq 2 \cdot T(n/2) + n .
\end{equation*}
</div>
<div class="para">By substituting the induction hypothesis into this inequality, we get</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{c c c}
T(n)  &amp; \leq  &amp; 2 \cdot  (n/2) \log (n/2) + n \\
&amp; =  &amp; n \log (n/2) + n \\
&amp; =  &amp; n \left( \log n - \log 2 \right) + n \\
&amp; =  &amp; n \left( \log n - 1 \right) + n \\
&amp; =  &amp; n \log n .
\end{array}
\end{equation*}
</div>
<div class="para">Thus, by induction, <span class="process-math">\(T(n) \leq n \log n\)</span> for any integer <span class="process-math">\(n\)</span> that is a power of <span class="process-math">\(2\text{.}\)</span>
</div>
</div> <div class="para">Until now, we have only counted the number of comparisons made by algorithm <code class="code-inline tex2jax_ignore">MergeSort</code>. It follows from the pseudocode that the total running time, i.e., the total number of “elementary” steps, is within a constant factor of the total number of comparisons. Therefore, if <span class="process-math">\(n\)</span> is a power of <span class="process-math">\(2\text{,}\)</span> the running time of algorithm <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code> is <span class="process-math">\(O(n \log n)\text{.}\)</span>
</div> <div class="para logical">
<div class="para">For general values of <span class="process-math">\(n\text{,}\)</span> the recurrence relation for the number of comparisons becomes the following:</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{lcl}
T(n)  &amp; =  &amp; 0 , \mbox{ if  or }  \\
T(n)  &amp; \leq  &amp; T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil)
+ n , \mbox{ if }
\end{array}
\end{equation*}
</div>
</div> <div class="para">It can be shown by induction that this recurrence relation solves to <span class="process-math">\(T(n) = O(n \log n)\text{.}\)</span> We have proved the following result:</div> <article class="theorem theorem-like"><h5 class="heading">
<span class="type">Theorem</span><span class="space"> </span><span class="codenumber">9.3.7</span><span class="period">.</span><span class="space"> </span><span class="title">Big O of MergeSort.</span>
</h5>
<div class="para">For any list <span class="process-math">\(L\)</span> of <span class="process-math">\(n\)</span> numbers, the running time of algorithm <code class="code-inline tex2jax_ignore">MergeSort(L,n)</code> is <span class="process-math">\(O(n \log n)\text{.}\)</span>
</div></article></article><span class="incontext"><a href="section9_3-AlgorthmicComplexity.html#ex-complexity-merge-sort" class="internal">in-context</a></span>
</body>
</html>
