<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="hiddenproof"><h4 class="heading"><span class="type">Proof</span></h4>
<div class="para">We prove that the language accepted by a DFA is regular. The proof for NFAs follows from the equivalence between DFAs and NFAs.</div> <div class="para logical">
<div class="para">Suppose that <span class="process-math">\(M\)</span> is a DFA, where <span class="process-math">\(M=(Q,\Sigma,q_0,\delta,F)\text{.}\)</span> Let <span class="process-math">\(n\)</span> be the number of states in <span class="process-math">\(M\text{,}\)</span> and write <span class="process-math">\(Q=\{q_0,q_1,\dots,q_{n-1}\}\text{.}\)</span> We want to consider computations in which <span class="process-math">\(M\)</span> starts in some state <span class="process-math">\(q_i\text{,}\)</span> reads a string <span class="process-math">\(w\text{,}\)</span> and ends in state <span class="process-math">\(q_k\text{.}\)</span> In such a computation, <span class="process-math">\(M\)</span> might go through a series of intermediates states between <span class="process-math">\(q_i\)</span> and <span class="process-math">\(q_k\text{:}\)</span>
</div>
<div class="displaymath process-math">
\begin{equation*}
q_i\longrightarrow p_1\longrightarrow p_2 \cdots\longrightarrow
p_r\longrightarrow q_k 
\end{equation*}
</div>
<div class="para">We are interested in computations in which all of the intermediate states--- <span class="process-math">\(p_1,p_2,\dots,p_r\)</span>---are in the set <span class="process-math">\(\{q_0,q_1,\dots,q_{j-1}\}\text{,}\)</span> for some number~ <span class="process-math">\(j\text{.}\)</span> We define <span class="process-math">\(R_{i,j,k}\)</span> to be the set of all strings <span class="process-math">\(w\)</span> in <span class="process-math">\(\Sigma^*\)</span> that are consumed by such a computation. That is, <span class="process-math">\(w\in R_{i,j,k}\)</span> if and only if when <span class="process-math">\(M\)</span> starts in state <span class="process-math">\(q_i\)</span> and reads <span class="process-math">\(w\text{,}\)</span> it ends in state <span class="process-math">\(q_k\text{,}\)</span> and all the intermediate states between <span class="process-math">\(q_i\)</span> and <span class="process-math">\(q_k\)</span> are in the set <span class="process-math">\(\{q_0,q_1,\dots,q_{j-1}\}\text{.}\)</span> <span class="process-math">\(R_{i,j,k}\)</span> is a language over <span class="process-math">\(\Sigma\text{.}\)</span> We show that <span class="process-math">\(R_{i,j,k}\)</span> for <span class="process-math">\(0\leq i \lt n , 0\leq j \leq n, 0\leq k lt
n\text{.}\)</span>
</div>
</div> <div class="para">Consider the language <span class="process-math">\(R_{i,0,k}\text{.}\)</span> For <span class="process-math">\(w\in R_{i,0,k}\text{,}\)</span> the set of allowable intermediate states is empty. Since there can be no intermediate states, it follows that there can be at most one step in the computation that starts in state <span class="process-math">\(q_i\text{,}\)</span> reads <span class="process-math">\(w\text{,}\)</span> and ends in state <span class="process-math">\(q_k\text{.}\)</span> So, <span class="process-math">\(|w|\)</span> can be at most one. This means that <span class="process-math">\(R_{i,0,k}\)</span> is finite, and hence is regular. (In fact, <span class="process-math">\(R_{i,0,k}=\{a\in\Sigma\st \delta(q_i,a)=q_k\}\text{,}\)</span> for <span class="process-math">\(i\ne k\text{,}\)</span> and <span class="process-math">\(R_{i,0,i}=\{\varep\}\cup\{a\in\Sigma\st
\delta(q_i,a)=q_i\}\text{.}\)</span> Note that in many cases, <span class="process-math">\(R_{i,0,k}\)</span> will be the empty set.)</div> <div class="para logical">
<div class="para">We now proceed by induction on <span class="process-math">\(j\)</span> to show that <span class="process-math">\(R_{i,j,k}\)</span> is regular for all <span class="process-math">\(i\)</span> and <span class="process-math">\(k\text{.}\)</span> We have proved the base case, <span class="process-math">\(j=0\text{.}\)</span> Suppose that <span class="process-math">\(0\leq j \lt n \)</span> we already know that <span class="process-math">\(R_{i,j,k}\)</span> is regular for all <span class="process-math">\(i\)</span> and all <span class="process-math">\(k\text{.}\)</span> We need to show that <span class="process-math">\(R_{i,j+1,k}\)</span> is regular for all <span class="process-math">\(i\)</span> and <span class="process-math">\(k\text{.}\)</span> In fact,</div>
<div class="displaymath process-math">
\begin{equation*}
R_{i,j+1,k}=R_{i,j,k}\cup
\left( R_{i,j,j}R_{j,j,j}^*R_{j,j,k}\right) 
\end{equation*}
</div>
<div class="para">which is regular because <span class="process-math">\(R_{i,j,k}\)</span> is regular for all <span class="process-math">\(i\)</span> and <span class="process-math">\(k\text{,}\)</span> and because the union, concatenation, and Kleene star of regular languages are regular.</div>
</div> <div class="para">To see that the above equation holds, consider a string <span class="process-math">\(w\in\Sigma^*\text{.}\)</span> Now, <span class="process-math">\(w\in R_{i,j+1,k}\)</span> if and only if when <span class="process-math">\(M\)</span> starts in state <span class="process-math">\(q_i\)</span> and reads <span class="process-math">\(w\text{,}\)</span> it ends in state <span class="process-math">\(q_k\text{,}\)</span> with all intermediate states in the computation in the set <span class="process-math">\(\{q_0,q_1,\dots,q_j\}\text{.}\)</span> Consider such a computation. There are two cases: Either <span class="process-math">\(q_j\)</span> occurs as an intermediate state in the computation, or it does not. If it does <em class="emphasis">not</em> occur, then all the intermediate states are in the set <span class="process-math">\(\{q_0,q_1,\dots,q_{j-1}\}\text{,}\)</span> which means that in fact <span class="process-math">\(w\in R_{i,j,k}\text{.}\)</span> If <span class="process-math">\(q_j\)</span> <em class="emphasis">does</em> occur as an intermediate state in the computation, then we can break the computation into phases, by dividing it at each point where <span class="process-math">\(q_j\)</span> occurs as an intermediate state. This breaks <span class="process-math">\(w\)</span> into a concatenation <span class="process-math">\(w=xy_1y_2\cdots
y_rz\text{.}\)</span> The string <span class="process-math">\(x\)</span> is consumed in the first phase of the computation, during which <span class="process-math">\(M\)</span> goes from state <span class="process-math">\(q_i\)</span> to the first occurrence of <span class="process-math">\(q_j\text{;}\)</span> since the intermediate states in this computation are in the set <span class="process-math">\(\{q_0,q_1,\dots,q_{j-1}\},
x\in R_{i,j,j}\text{.}\)</span> The string <span class="process-math">\(z\)</span> is consumed by the last phase of the computation, in which <span class="process-math">\(M\)</span> goes from the final occurrence of <span class="process-math">\(q_j\)</span> to <span class="process-math">\(q_k\text{,}\)</span> so that <span class="process-math">\(z\in R_{j,j,k}\text{.}\)</span> And each string <span class="process-math">\(y_t\)</span> is consumed in a phase of the computation in which <span class="process-math">\(M\)</span> goes from one occurrence of <span class="process-math">\(q_j\)</span> to the next occurrence of <span class="process-math">\(q_j\text{,}\)</span> so that <span class="process-math">\(y_r\in R_{j,j,j}\text{.}\)</span> This means that <span class="process-math">\(w=xy_1y_2\cdots y_rz\in R_{i,j,j}R_{j,j,j}^*R_{j,j,k}\text{.}\)</span>
</div> <div class="para logical">
<div class="para">We now know, in particular, that <span class="process-math">\(R_{0,n,k}\)</span> is a regular language for all <span class="process-math">\(k\text{.}\)</span> But <span class="process-math">\(R_{0,n,k}\)</span> consists of all strings <span class="process-math">\(w\in\Sigma^*\)</span> such that when <span class="process-math">\(M\)</span> starts in state <span class="process-math">\(q_0\)</span> and reads <span class="process-math">\(w\text{,}\)</span> it ends in state <span class="process-math">\(q_k\)</span> (with \textbf{no} restriction on the intermediate states in the computation, since every state of <span class="process-math">\(M\)</span> is in the set \{q_0,q_1,\dots,q_{n-1}\}). To finish the proof that <span class="process-math">\(L(M)\)</span> is regular, it is only necessary to note that</div>
<div class="displaymath process-math">
\begin{equation*}
L(M)=\bigcup_{q_k\in F} R_{0,n,k} 
\end{equation*}
</div>
<div class="para">which is regular since it is a union of regular languages. This equation is true since a string <span class="process-math">\(w\)</span> is in <span class="process-math">\(L(M)\)</span> if and only if when <span class="process-math">\(M\)</span> starts in state <span class="process-math">\(q_0\)</span> and reads <span class="process-math">\(w\text{,}\)</span> in ends in some accepting state <span class="process-math">\(q_k\in F\text{.}\)</span> This is the same as saying <span class="process-math">\(w\in R_{0,n,k}\)</span> for some <span class="process-math">\(k\)</span> with <span class="process-math">\(q_k\in
F\text{.}\)</span>
</div>
</div></article><span class="incontext"><a href="sec-FSA-and-Regular-Languages.html#proof-54" class="internal">in-context</a></span>
</body>
</html>
