<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math"><article class="hiddenproof"><div class="para">Suppose we are given an NFA <span class="process-math">\(N = (P, \Sigma, p_0, \partial, F_p)\text{,}\)</span> and we want to build a DFA <span class="process-math">\(D=(Q, \Sigma, q_0, \delta, F_q)\)</span> that accepts the same language. The idea is to make the states in <span class="process-math">\(D\)</span> correspond to {\em subsets} of <span class="process-math">\(N\)</span>'s states, and then to set up <span class="process-math">\(D\)</span>'s transition function <span class="process-math">\(\delta\)</span> so that for any string <span class="process-math">\(w\text{,}\)</span> <span class="process-math">\(\delta^*(q_0, w)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,w)\text{;}\)</span> i.e.\ the {\bf single} state that <span class="process-math">\(w\)</span> gets you to in <span class="process-math">\(D\)</span> corresponds to the {\bf set} of states that <span class="process-math">\(w\)</span> could get you to in <span class="process-math">\(N\text{.}\)</span> If any of those states is accepting in <span class="process-math">\(N\text{,}\)</span> <span class="process-math">\(w\)</span> would be accepted by <span class="process-math">\(N\text{,}\)</span> and so the corresponding state in <span class="process-math">\(D\)</span> would be made accepting as well.</div> <div class="para">So how do we make this work? The first thing to do is to deal with a start state <span class="process-math">\(q_0\)</span> for <span class="process-math">\(D\text{.}\)</span> If we're going to make this state correspond to a subset of <span class="process-math">\(N\)</span>'s states, what subset should it be? Well, remember (1) that in any DFA, <span class="process-math">\(\delta^*(q_0, \varep) = q_0\text{;}\)</span> and (2) we want to make <span class="process-math">\(\delta^*(q_0,
w)\)</span> correspond to <span class="process-math">\(\partial^*(p_0,w)\)</span> for every <span class="process-math">\(w\text{.}\)</span> Putting these two limitations together tells us that we should make <span class="process-math">\(q_0\)</span> correspond to <span class="process-math">\(\partial^*(p_0,
\varep)\text{.}\)</span> So <span class="process-math">\(q_0\)</span> corresponds to the subset of all of <span class="process-math">\(N\)</span>'s states that can be reached with no input.</div> <div class="para logical">
<div class="para">Now we progressively set up <span class="process-math">\(D\)</span>'s transition function <span class="process-math">\(\delta\)</span> by repeatedly doing the following:</div>
<ul class="disc">
<li><div class="para">find a state <span class="process-math">\(q\)</span> that has been added to <span class="process-math">\(D\)</span> but whose out-transitions have not yet been added. (Note that <span class="process-math">\(q_0\)</span> initially fits this description.) Remember that the state <span class="process-math">\(q\)</span> corresponds to some subset <span class="process-math">\(\{p_1,
\ldots , p_n\}\)</span> of <span class="process-math">\(N\)</span>'s states.</div></li>
<li><div class="para">for each input symbol <span class="process-math">\(a\text{,}\)</span> look at all <span class="process-math">\(N\)</span>'s states that can be reached from any one of <span class="process-math">\(p_1, \ldots , p_n\)</span> by consuming <span class="process-math">\(a\)</span> (perhaps making some <span class="process-math">\(\varep\)</span>-transitions as well). That is, look at <span class="process-math">\(\partial^*(p_1,a)
\cup \ldots \cup
\partial^*(p_n,a)\text{.}\)</span> If there is not already a DFA state <span class="process-math">\(q'\)</span> that corresponds to this subset of <span class="process-math">\(N\)</span>'s states, then add one, and add the transition <span class="process-math">\(\delta(q, a)= q'\)</span> to <span class="process-math">\(D\)</span>'s transitions.</div></li>
</ul>
</div> <div class="para">The above process must halt eventually, as there are only a finite number of states <span class="process-math">\(n\)</span> in the NFA, and therefore there can be at most <span class="process-math">\(2^n\)</span> states in the DFA, as that is the number of subsets of the NFA's states. The final states of the new DFA are those where at least one of the associated NFA states is an accepting state of the NFA.</div> <div class="para">Can we now argue that <span class="process-math">\(L(D) = L(N)\text{?}\)</span> We can, if we can argue that <span class="process-math">\(\delta^*(q_0,w)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,w)\)</span> for all <span class="process-math">\(w
\in\Sigma^*\text{:}\)</span> if this latter property holds, then <span class="process-math">\(w \in L(D)\)</span> iff <span class="process-math">\(\delta^*(q_0,w)\)</span> is accepting, which we made be so iff <span class="process-math">\(\partial^*(p_0,w)\)</span> contains an accepting state of <span class="process-math">\(N\text{,}\)</span> which happens iff <span class="process-math">\(N\)</span> accepts <span class="process-math">\(w\)</span> i.e.\ iff <span class="process-math">\(w \in L(N)\text{.}\)</span>
</div> <div class="para">So can we argue that <span class="process-math">\(\delta^*(q_0,w)\)</span> does in fact correspond to <span class="process-math">\(\partial^*(p_0,w)\)</span> for all <span class="process-math">\(w\text{?}\)</span> We can, using induction on the length of <span class="process-math">\(w\text{.}\)</span>
</div> <div class="para">First, a preliminary observation. Suppose <span class="process-math">\(w=xa\text{,}\)</span> i.e.\ <span class="process-math">\(w\)</span> is the string <span class="process-math">\(x\)</span> followed by the single symbol <span class="process-math">\(a\text{.}\)</span> How are <span class="process-math">\(\partial^*(p_0,x)\)</span> and <span class="process-math">\(\partial^*(p_0,w)\)</span> related? Well, recall that <span class="process-math">\(\partial^*(p_0,x)\)</span> is the set of all states that <span class="process-math">\(N\)</span> can reach when it starts in <span class="process-math">\(p_0\)</span> and consumes <span class="process-math">\(x\text{:}\)</span> <span class="process-math">\(\partial^*(p_0,x) = \{p_1,
\ldots, p_n\}\)</span> for some states <span class="process-math">\(p_1, \ldots, p_n\text{.}\)</span> Now, <span class="process-math">\(w\)</span> is just <span class="process-math">\(x\)</span> with an additional <span class="process-math">\(a\text{,}\)</span> so where might <span class="process-math">\(N\)</span> end up if it starts in <span class="process-math">\(p_0\)</span> and consumes <span class="process-math">\(w\text{?}\)</span> We know that <span class="process-math">\(x\)</span> gets <span class="process-math">\(N\)</span> to <span class="process-math">\(p_1\)</span> or <span class="process-math">\(\ldots\)</span> or <span class="process-math">\(p_n\text{,}\)</span> so <span class="process-math">\(xa\)</span> gets <span class="process-math">\(N\)</span> to any state that can be reached from <span class="process-math">\(p_1\)</span> with an <span class="process-math">\(a\)</span> (and maybe some <span class="process-math">\(\varep\)</span>-transitions), and to any state that can be reached from <span class="process-math">\(p_2\)</span> with an <span class="process-math">\(a\)</span> (and maybe some <span class="process-math">\(\varep\)</span>-transitions), etc. Thus, our relationship between <span class="process-math">\(\partial^*(p_0,x)\)</span> and <span class="process-math">\(\partial^*(p_0,w)\)</span> is that if <span class="process-math">\(\partial^*(p_0,x)
= \{p_1, \ldots, p_n\}\text{,}\)</span> then <span class="process-math">\(\partial^*(p_0,w) = \partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\text{.}\)</span> With this observation in hand, let's proceed to our proof by induction.</div> <div class="para logical">
<div class="para">We want to prove that <span class="process-math">\(\delta^*(q_0,w)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,w)\)</span> for all <span class="process-math">\(w \in\Sigma^*\text{.}\)</span> We use induction on the length of <span class="process-math">\(w\text{.}\)</span>
</div>
<ol class="decimal">
<li><div class="para">Base case: Suppose <span class="process-math">\(w\)</span> has length 0. The only string <span class="process-math">\(w\)</span> with length 0 is <span class="process-math">\(\varep\text{,}\)</span> so we want to show that <span class="process-math">\(\delta^*(q_0,\varep)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,\varep)\text{.}\)</span> Well, <span class="process-math">\(\delta^*(q_0, \varep) =
q_0\text{,}\)</span> since in a DFA, <span class="process-math">\(\delta^*(q, \varep) = q\)</span> for any state~ <span class="process-math">\(q\text{.}\)</span> We explicitly made <span class="process-math">\(q_0\)</span> correspond to <span class="process-math">\(\partial^*(p_0,\varep)\text{,}\)</span> and so the property holds for <span class="process-math">\(w\)</span> with length 0.</div></li>
<li>
<div class="para">Inductive case: Assume that the desired property holds for some number <span class="process-math">\(n\text{,}\)</span> i.e.\ that <span class="process-math">\(\delta^*(q_0,x)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,x)\)</span> for all <span class="process-math">\(x\)</span> with length <span class="process-math">\(n\text{.}\)</span> Look at an arbitrary string <span class="process-math">\(w\)</span> with length <span class="process-math">\(n+1\text{.}\)</span> We want to show that <span class="process-math">\(\delta^*(q_0,w)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,w)\text{.}\)</span> Well, the string <span class="process-math">\(w\)</span> must look like <span class="process-math">\(xa\)</span> for some string <span class="process-math">\(x\)</span> (whose length is <span class="process-math">\(n\)</span>) and some symbol <span class="process-math">\(a\text{.}\)</span> By our inductive hypothesis, we know <span class="process-math">\(\delta^*(q_0,x)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,x)\text{.}\)</span> We know <span class="process-math">\(\partial^*(p_0,x)\)</span> is a set of <span class="process-math">\(N\)</span>'s states, say <span class="process-math">\(\partial^*(p_0,x) =
\{p_1, \ldots, p_n\}\text{.}\)</span>
</div>
<div class="para">At this point, our subsequent reasoning might be a bit clearer if we give explicit names to <span class="process-math">\(\delta^*(q_0,w)\)</span> (the state <span class="process-math">\(D\)</span> reaches on input <span class="process-math">\(w\)</span>) and <span class="process-math">\(\delta^*(q_0,x)\)</span> (the state <span class="process-math">\(D\)</span> reaches on input <span class="process-math">\(x\)</span>). Call <span class="process-math">\(\delta^*(q_0, w)\)</span> \ <span class="process-math">\(q_w\text{,}\)</span> and call <span class="process-math">\(\delta^*(q_0,x)\)</span> \ <span class="process-math">\(q_x\text{.}\)</span> We know, because <span class="process-math">\(w=xa\text{,}\)</span> there must be an <span class="process-math">\(a\)</span>-transition from <span class="process-math">\(q_x\)</span> to <span class="process-math">\(q_w\text{.}\)</span> Look at how we added transitions to <span class="process-math">\(\delta\text{:}\)</span> the fact that there is an <span class="process-math">\(a\)</span>-transition from <span class="process-math">\(q_x\)</span> to <span class="process-math">\(q_w\)</span> means that <span class="process-math">\(q_w\)</span> corresponds to the set <span class="process-math">\(\partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span> of <span class="process-math">\(N\)</span>'s states. By our preliminary observation, <span class="process-math">\(\partial^*(p_1,a) \cup \ldots \cup
\partial^*(p_n,a)\)</span> is just <span class="process-math">\(\partial^*(p_0,w)\text{.}\)</span> So <span class="process-math">\(q_w\)</span> (or <span class="process-math">\(\delta^*(q_0,w)\)</span>) corresponds to <span class="process-math">\(\partial^*(p_0,w)\text{,}\)</span> which is what we wanted to prove. Since <span class="process-math">\(w\)</span> was an arbitrary string of length <span class="process-math">\(n+1\text{,}\)</span> we have shown that the property holds for <span class="process-math">\(n+1\text{.}\)</span>
</div>
</li>
</ol>
</div> <div class="para">Altogether, we have shown by induction that <span class="process-math">\(\delta^*(q_0,w)\)</span> corresponds to <span class="process-math">\(\partial^*(p_0,w)\)</span> for all <span class="process-math">\(w \in\Sigma^*\text{.}\)</span> As indicated at the very beginning of this proof, that is enough to prove that <span class="process-math">\(L(D)= L(N)\text{.}\)</span> So for any NFA <span class="process-math">\(N\text{,}\)</span> we can find a DFA <span class="process-math">\(D\)</span> that accepts the same language.</div></article></body>
</html>
