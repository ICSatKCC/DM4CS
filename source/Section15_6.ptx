<?xml version="1.0" encoding="UTF-8"?>
<section xml:id="sec-turing-machines-comp">
  <title>Turing Machines and Computability</title>
  <!-- adapted from Foundations of Computation chapter on Turing Machines-->
  <idx><h>Turing Machine</h></idx>
  <idx><h>Computability</h></idx>
  <introduction>
    <p>
      In <xref ref="sec-FSA-and-Regular-Languages"/>, we saw that there is a neat correspondence
between regular expressions and finite automata.  That is, a language
is generated by a regular expression if and only if that language is
accepted by a finite automaton.
    </p>
    <p>
      In <xref ref="sec-grammars"/>, we introduced the class of context-free languages,
and we have considered how context-free grammars can be used to
generate context-free languages.  You might wonder whether there is any
type of automaton that can be used to recognize context-free languages.
In fact, there is:  The abstract machines known as 
<term>pushdown automata</term> that utilize a stack in addition to a finite automaton, can be used to define
context-free languages. These and languages that are not context-free (or context-sensitive languages) will not be covered in this text. If you wish to learn more 
about pushdown automata, non-context-free languages, or general grammars please refer to the
original source text for this chapter: <url href="https://math.hws.edu/FoundationsOfComputation/">Foundations of Computation</url>, Chapter 4
    </p>

    <p>We saw hints in the previous sections that
      ``computation'' is a more general concept than we might have thought.
      In this chapter, we will see that computer programs are equivalent, in terms of their computational
      power, to a particularly simple model
      of computation known as a <term>Turing machine</term>.  We shall also see
      that there are limits to what can be done by computing.
    </p>
  </introduction>


   <subsection xml:id="subsec-turing">
      <title>Turing Machines</title>
      
   <p>Historically, the theoretical study of computing began before computers
existed.  One of the early models of computation was developed in the
1930s by the British mathematician, Alan Turing, who was interested in
studying the theoretical abilities and limitations of computation.
His model for computation is a very simple abstract computing machine
which has come to be known as a <term>Turing machine</term>.  While Turing
machines are not applicable in the same way that regular expressions,
finite-state automata, and grammars are applicable, their use as a
fundamental model for computation means that every computer scientist
should be familiar with them, at least in a general way.</p>

<p>A Turing machine is really not much more complicated than a finite-state 
automaton or a pushdown automaton.<aside>In fact, Turing machines can
be shown to be equivalent in their computational power
to pushdown automata with two independent stacks.</aside>
Like a FSA, a Turing machine has a finite number of 
possible states, and it changes from state to state as it computes.
However, a Turing machine also has an infinitely long <term>tape</term>
that it can use for input and output.  The tape extends to infinity in
both directions.  The tape is divided into <term>cells</term>, which
are in one-to-one correspondence with the
integers, <m>\Z</m>. Each cell can either be blank or it can hold a symbol from
a specified alphabet.  The Turing machine can move back and forth
along this tape, reading and writing symbols and changing state.
It can read only one cell at a time, and possibly write a new
value in that cell.  After doing this, it can change state and
it can move by one cell either to the left or to the right.
This is how the Turing machine computes.  To use a Turing machine,
you would write some input on its tape, start the machine, and let
it compute until it halts.  Whatever is written on the tape at that
time is the output of the computation.</p>
<p>
   You might want to visualize a Turing machine as a physical machine 
   such as in this simple diagram: 

<figure width="80%" xml:id="fig-TM">
  
   <image source="images/Turing_machine" width="50%">
      <description>Basic graphical representation of a Turing machine.</description>
   </image>
<caption><url href="https://commons.wikimedia.org/wiki/File:Turing_machine.png">Kevd1337></url>
   , Public domain, via Wikimedia Commons</caption>
   
</figure>
However, these kinds of diagrams do not tell us anything about the functioning of a particular machine.</p>


<p>Although the tape is infinite, only a finite number
of cells can be non-blank at any given time.  
If you don't like the idea
of an infinite tape, you can think of a finite tape that can be
extended to an arbitrarily large size as the Turing machine computes:
If the Turing machine gets to either end of the tape, it will pause and
wait politely until you add a new section of tape.  In other words,
it's not important that the Turing machine have an infinite amount of
memory, only that it can use as much memory as it needs for a given
computation, up to any arbitrarily large size.   In this way, a Turing
machine is like a computer that can ask you to buy it a new disk drive
whenever it needs more storage space to continue a computation.<aside>The
tape of a Turing machine can be used to store arbitrarily large amounts of
information in a straightforward way.  Although we can imagine using
an arbitrary amount of memory with a computer, it's not so easy.  Computers
aren't set up to keep track of unlimited amounts of data.  If you think 
about how it might be done, you probably won't come with anything better
than an infinite tape. (The problem is that computers use integer-valued
addresses to keep track of data locations.  If a limit is put on
the number of bits in an address, then only a fixed, finite amount
of data can be addressed.  If no limit is put on the number of bits
in an address, then we are right back to the problem of storing an
arbitrarily large piece of data---just to represent an address!)</aside></p>

<p>A given Turing machine has a fixed, finite set of states.  One of
these states is designated as the <term>start
state</term>.  This is the state in which the Turing machine begins a computation.
Another special state is the <term>halt state</term>.  
The Turing machine's computation ends when it enters its
halt state.  It is possible that a computation might never end because
the machine never enters the halt state.  This is analogous to an 
infinite loop in a computer program.</p>

<p>At each step in its computation,
the Turing machine reads the contents of the tape cell where it is located.
Depending on its state and the symbol that it reads, the machine
writes a symbol (possibly the same symbol) to the cell, moves one cell
either to the left or to the right, and (possibly) changes its state.
The output symbol, direction of motion, and new state are determined
by the current state and the input symbol.  Note that either the input
symbol, the output symbol, or both, can be blank. 
A Turing machine has a fixed set of <term>rules</term>
that tell it how to compute.  Each rule
specifies the output symbol, direction of motion, and new state for
some combination of current state and input symbol.  The machine has
a rule for every possible combination of current state and input symbol,
except that there are no rules for what happens if the current state
is the halt state.  Of course, once the machine enters the halt state,
its computation is complete and the machine simply stops.</p>

<p>I will use the character # to represent a blank in a way
that makes it visible.  I will always use <m>h</m> to represent the halt
state.  I will indicate the directions, left and right, with
<m>L</m> and <m>R</m>, so that <m>\{L,R\}</m> is the set of possible directions of
motion.  With these conventions, we can give the formal definition of
a Turing machine as follows:</p>

<definition xml:id="def-turing-machine">
   <title>Turing Machine</title>
   <idx><h>Turing Machine</h></idx>
   <statement>
      <p>
         A <term>Turing machine</term> is a 4-tuple <m>(Q,\Lambda,q_0,\delta)</m>,
where:
<ol>
   <li>
      <p>
         <m>Q</m> is a finite set of states, including the halt state, <m>h</m>.
      </p>
   </li>
   <li>
      <p>
         <m>\Lambda</m> is an alphabet which includes the blank symbol, #.
      </p>
   </li>
   <li>
      <p>
         <m>q_0\in Q</m> is the start state.

      </p>
   </li>
   <li>
      <p>
         <m>\delta\colon (Q - \{h\})\times\Lambda \to \Lambda\times 
            \{L,R\}\times Q</m> is the transition function.  The fact that
            <m>\delta(q,\sigma)=(\tau,d,r)</m> means that when the Turing machine is
            in state <m>q</m> and reads the symbol <m>\sigma</m>, it writes the symbol
            <m>\tau</m>, moves one cell in the direction <m>d</m>, and enters state <m>r</m>.
      </p>
   </li>
</ol>

      </p>
   </statement>
</definition>

<p>
Even though this is the formal definition, it's easier to work with
a transition diagram representation of Turing machines.  The transition
diagram for a Turing machine is similar to the transition diagram for
a DFA.  However, there are no ``accepting'' states (only a halt state).
Furthermore, there must be a way to specify the output symbol and
the direction of motion for each step of the computation.
We do this by labeling arrows with notations of the
form <m>(\sigma,\tau,L)</m> and <m>(\sigma,\tau,R)</m>, where
<m>\sigma</m> and <m>\tau</m> are symbols in the Turing machine's alphabet.
For example,

<image source="images/turing1" width="50%">
   <description>a simple Turing machine transition diagram</description>
</image>
indicates that when the machine is in state <m>q_0</m> and
reads an <m>a</m>, it writes a <m>b</m>, moves left, and enters state <m>h</m>.
</p>


<p>Here, for example, is a transition diagram for a simple Turing machine
that moves to the right, changing <m>a</m>'s to <m>b</m>'s and vice
versa, until it finds a <m>c</m>.  It leaves blanks (#'s) unchanged.
When and if the machine encounters a <m>c</m>, it moves to the left
and halts:
<image source="images/turing2" width="60%">
   <description>Transition diagram for a simple Turing machine
      that moves to the right, changing <m>a</m>'s to <m>b</m>'s and vice
      versa, until it finds a <m>c</m>.</description>
</image>
</p>


<p>To simplify the diagrams, I will leave out any transitions that are
not relevant to the computation that I want the machine to perform.
You can assume that the action for any omitted transition is
to write the same symbol that was read, move right, and halt.</p>

<p>For example, shown below is a transition diagram for a Turing machine
that makes a copy of a string of <m>a</m>'s and <m>b</m>'s.  To use this machine,
you would write a string of <m>a</m>'s and <m>b</m>'s on its tape, place
the machine on the first character of the string, and start the
machine in its start state,~<m>q_0</m>.  When the machine halts, there will be
two copies of the string on the tape, separated by a blank.
The machine will be positioned on the first character of the leftmost
copy of the string.  Note that this machine uses <m>c</m>'s and
<m>d</m>'s in addition to <m>a</m>'s and <m>b</m>'s.  While it is copying the
input string, it temporarily changes the <m>a</m>'s and <m>b</m>'s that it
has copied to <m>c</m>'s and <m>d</m>'s, respectively.  In this way it can 
keep track of which characters it has already copied.  After the
string has been copied, the machine changes the <m>c</m>'s and <m>d</m>'s
back to <m>a</m>'s and <m>b</m>'s before halting.

<image source="images/turing3" width="80%">
   <description>Transition diagram for Turing machine described above.</description>
</image></p>

<p>
In this machine, state <m>q_0</m> checks whether the next character
is an <m>a</m>, a <m>b</m>, or a # (indicating the end of the string).
States <m>q_1</m> and <m>q_2</m> add an <m>a</m> to the end of the new string,
and states <m>q_3</m> and <m>q_4</m> do the same thing with a <m>b</m>.
States <m>q_5</m> and <m>q_6</m> return the machine to the next character
in the input string.  When the end of the input string is reached,
state <m>q_7</m> will move the machine back to the start of the input
string, changing <m>c</m>'s and <m>d</m>'s back to <m>a</m>'s and <m>b</m>'s as it goes.
Finally, when the machine hits the # that precedes the input string,
it moves to the right and halts.  This leave it back at the first
character of the input string.  It would be a good idea to work through
the execution of this machine for a few sample input strings.
You should also check that it works even for an input string of
length zero.
</p>


<p>Our primary interest in Turing machines is as language processors.
Suppose that <m>w</m> is a string over an alphabet <m>\Sigma</m>.  We will assume
that <m>\Sigma</m> does not contain the blank symbol.  We can use <m>w</m> as
input to a Turing machine <m>M=(Q,\Lambda,q_0,\delta)</m> provided that
<m>\Sigma\SUB\Lambda</m>.  To use <m>w</m> as input for <m>M</m>, we will write
<m>w</m> on <m>M</m>'s tape and assume that the remainder of the tape is blank.
We place the machine on the cell containing the first character
of the string, except that if <m>w=\EMPTYSTRING</m> then we simply place the
machine on a completely blank tape.   Then we start the machine in its 
initial state, <m>q_0</m>, and see what computation it performs.
We refer to this setup as ``running <m>M</m> with input <m>w</m>.''</p>

<p>
When <m>M</m> is run with input <m>w</m>, it is possible that it will just keep
running forever without halting.  In that case, it doesn't make
sense to ask about the output of the computation.  Suppose however
that <m>M</m> does halt on input <m>w</m>.  Suppose, furthermore, that when
<m>M</m> halts, its tape is blank except for a string <m>x</m> of non-blank
symbols, and that the machine is located on the first character
of <m>x</m>.  In this case, we will say that ``<m>M</m> halts with output <m>x</m>.''
In addition, if <m>M</m> halts with an entirely blank tape, we say that
``<m>M</m> halts with output <m>\varepsilon</m>.''
Note that when we run <m>M</m> with input <m>w</m>, one of three things can happen:
(1)~<m>M</m>~might halt with some string as output; (1)~<m>M</m>~might fail to halt; 
or (3)~<m>M</m>~might halt in some configuration that doesn't
count as outputting any string.</p>

<p>The fact that a Turing machine can produce an output value allows us
for the first time to deal with computation of <em>functions</em>.
A function <m>f\colon A\to B</m> takes an input value in the set <m>A</m>
and produces an output value in the set <m>B</m>.  If the sets are sets
of strings, we can now ask whether the values of the function can
be computed by a Turing machine.  That is, is there a Turing machine <m>M</m>
such that, given any string <m>w</m> in the domain of <m>f</m> as input,
<m>M</m> will compute as its output the string <m>f(w)</m>.  If this is
that case, then we say that <m>f</m> is a Turing-computable function.</p>

<definition xml:id="def-turing-computable">
   <title>Turing-computable</title>
   <idx><h>Turing-computable</h></idx>
   <statement>
      <p>Suppose
         that <m>\Sigma</m> and <m>\Gamma</m> are alphabets that do not contain # and that
         <m>f</m> is a function from <m>\Sigma^*</m> to <m>\Gamma^*</m>.  We say that
         <m>f</m> is <term>Turing-computable</term> if there is a Turing machine
         <m>M=(Q,\Lambda,q_0,\delta)</m> such that <m>\Sigma\SUB\Lambda</m> and <m>\Gamma\SUB\Lambda</m>
         and for each string <m>w\in\Sigma^*</m>, when <m>M</m> is run with input <m>w</m>,
         it halts with output <m>f(w)</m>.  In this case, we say that <m>M</m>
         <term>computes</term> the function <m>f</m>.
      </p>
   </statement>
</definition>

<p>
 For example, let <m>\Sigma=\{a\}</m> and define <m>f\colon\Sigma^*\to\Sigma^*</m>
by <m>f(a^n)=a^{2n}</m>, for <m>n\in\N</m>.  Then <m>f</m> is Turing-computable
since it is computed by this Turing machine:

<image source="images/turing4" width="90%">
   <description>Transition diagram for Turing machine <m>f</m> described above.</description>
</image>
</p>

<p>We can also use Turing machines to define ``computable languages.''
There are actually two different notions of Turing-computability
for languages.  One is based on the idea of Turing-computability
for functions.  Suppose that <m>\Sigma</m> is an alphabet and that
<m>L\SUB\Sigma^*</m>.  The <term>characteristic function</term> of <m>L</m>
is the function <m>\chi_L\colon\Sigma^*\to\{0,1\}</m> defined
by the fact that <m>\chi_L(w)=1</m> if <m>w\in L</m> and <m>\chi_L(w)=0</m>
if <m>w\not\in L</m>.  Note that given the function <m>\chi_L</m>,
<m>L</m> can be obtained as the set <m>L=\{w\in\Sigma^*\st \chi_L(w)=1\}</m>.
Given a language <m>L</m>, we can ask whether the corresponding function
<m>\chi_L</m> is Turing-computable.  If so, then we can use a Turing
machine to decide whether or not a given string <m>w</m> is in <m>L</m>.
Just run the machine with input <m>w</m>.  It will halt with output <m>\chi_L(w)</m>.
(That is, it will halt and when it does so, the tape will be blank except for
a 0 or a 1, and the machine will be positioned on the 0 or~1.)
If the machine halts with output 1, then <m>w\in L</m>.  If the machine halts with
output 0, then <m>w\not\in L</m>.</p>

<definition xml:id="def-turing-decidable">
   <title>Turing-decidable</title>
   <idx><h>Turing-decidable</h></idx>
   <statement>
      <p>
         Let <m>\Sigma</m> be an alphabet that does not contain # and let <m>L</m> be a language over <m>\Sigma</m>.
We say that <m>L</m> is <term>Turing-decidable</term> if there is a Turing machine
<m>M=(Q,\Lambda,q_0,\delta)</m> such that <m>\Sigma\SUB\Lambda</m>, <m>\{0,1\}\SUB\Lambda</m>,
and for each <m>w\in\Sigma^*</m>, when <m>M</m> is run with input <m>w</m>, it halts
with output <m>\chi_L(w)</m>.  (That is, it halts with output 0 or 1, and
the output is 0 if <m>w\not\in L</m> and is 1 if <m>w\in L</m>.)  In this case,
we say that <m>M</m> <term>decides</term> the language <m>L</m>.
      </p>
   </statement>
</definition>

<p>
The second notion of computability for languages is based on the
interesting fact that it is possible for a Turing machine to run
forever, without ever halting.
Whenever we run a Turing machine <m>M</m> with input <m>w</m>,
we can ask the question, will <m>M</m> ever halt or will it run forever?  If <m>M</m>
halts on input <m>w</m>, we will say that <m>M</m> ``accepts'' <m>w</m>.  We can then
look at all the strings over a given alphabet that are accepted by
a given Turing machine.  This leads to the notion of Turing-acceptable
languages.</p>

<definition xml:id="def-turing-acceptable">
   <title>Turing-acceptable</title>
   <idx><h>Turing-acceptable</h></idx>
   <statement>
      <p>
         Let <m>\Sigma</m> be an alphabet that does not contain #, and let <m>L</m> be a language over <m>\Sigma</m>.
We say that <m>L</m> is <term>Turing-acceptable</term> if there is a Turing machine
<m>M=(Q,\Lambda,q_0,\delta)</m> such that <m>\Sigma\SUB\Lambda</m>, and
for each <m>w\in\Sigma^*</m>, <m>M</m> halts on input <m>w</m> if and only if <m>w\in L</m>.
In this case, we say that <m>M</m> <term>accepts</term> the language <m>L</m>.
      </p>
   </statement>
</definition>

<p>It should be clear that any Turing-decidable language is Turing-acceptable.
In fact, if <m>L</m> is a language over an alphabet <m>\Sigma</m>,
and if <m>M</m> is a Turing machine that
decides <m>L</m>, then it is easy to modify <m>M</m> to produce a Turing machine
that accepts <m>L</m>.  At the point where <m>M</m> enters the halt state with
output 0, the new machine should enter a new state in which it simply
moves to the right forever, without ever halting.  Given an input
<m>w\in\Sigma^*</m>, the modified machine will halt if and only if <m>M</m>
halts with output 1, that is, if and only if <m>w\in L</m>.</p>

</subsection>

<subsection xml:id="subsec-computability">
   <title>Computability</title>
<idx><h>Computability</h></idx>   

<p>At this point, it would be useful to look at increasingly complex
Turing machines, such as those with more tapes, which compute increasingly complex functions and languages.
Although Turing machines are very simple devices, it turns out that
they can perform very sophisticated computations.  In fact, any
computation that can be carried out by a modern digital computer---even
one with an unlimited amount of memory---can be carried out by
a Turing machine.  Although it is not something that can be 
proved, it is widely believed that anything that can reasonably
be called ``computation'' can be done by a Turing machine.  This
claim is known as the <term>Church-Turing Thesis</term><idx><h>Church-Turing Thesis</h></idx>.</p>

<p>We do not have time to look at enough examples to convince you that
Turing machines are as powerful as computers, but the proof reduces
to the fact that computers are actually fairly simple in their basic
operation.  Everything that a computer does comes down to copying
data from one place to another, making simple comparisons between
two pieces of data, and performing some basic arithmetic operations.
It's possible for Turing machines to do all these things.  In fact,
it's possible to build a Turing machine to simulate the step-by-step
operation of a given computer.  Doing so proves that the Turing machine
can do any computation that the computer could do, although it will,
of course, work much, much more slowly.</p>

<p>We have used Turing machines to define Turing-acceptable languages
and Turing-decidable languages.  The definitions seem to depend
very much on the peculiarities of Turing machines.  But the same
classes of languages can be defined in other ways.  For example,
we could use programs running on an idealized computer, with an
unlimited amount of memory, to accept or decide languages.  Or we
could use <m>n</m>-tape Turing machines.  The
resulting classes of languages would be exactly the same as the
Turing-acceptable and Turing-decidable languages.</p>

<p>We could look at other ways of specifying languages ``computationally.''
One of the most natural is to imagine a Turing machine or computer
program that runs forever and outputs an infinite list of strings
over some alphabet <m>\Sigma</m>.  In the case of Turing machines, it's
convenient to think of a two-tape Turing machine that lists the strings
on its second tape.  The strings in the list form a language
over <m>\Sigma</m>.  A language that can be listed in this way is
said to be <idx><h>recursively enumerable language</h></idx> <term>recursively enumerable</term>. 
Note that we make no
assumption that the strings must be listed in any particular order,
and we allow the same string to appear in the output any number of
times.  Clearly, a recursively enumerable language is ``computable''
in some sense.  Perhaps we have found a new type of computable language.
But no---it turns out that we have just found another way of
describing the Turing-acceptable languages.  The following theorem
makes this fact official and adds one more way of describing
the same class of languages:
<aside>
   Discussion of the proof of this theorem can be found in the source document for this section: Section 5.2 of <url href="https://math.hws.edu/FoundationsOfComputation/">Foundations
   of Computation</url>
</aside>
</p>

<theorem xml:id="thm-turing-equivalence">
   <statement>
      <p>
         Let <m>\Sigma</m> be an alphabet and let <m>L</m> be a language over <m>\Sigma</m>.
Then the following are equivalent:
         <ol>
            <li>
               <p>
                  There is a Turing machine that accepts <m>L</m>.
               </p>
            </li>
            <li>
               <p>
                  There is a two-tape Turing machine that runs forever, making 
a list of strings on its second tape, such that a string <m>w</m> is in 
the list if and only if <m>w\in L</m>.
               </p>
            </li>
            <li>
               <p>
                  There is a Turing-computable function <m>f\colon\{a\}^*\to\Sigma^*</m>
such that <m>L</m> is the range of the function <m>f</m>.
               </p>
            </li>
         </ol>
      </p>
   </statement>
</theorem>

<!-- cut out rest of this section -->


<p>Next, we compare Turing machines to a completely different method
of specifying languages: grammars.  Suppose <m>G=(V,\Sigma,P,S)</m> is a general
grammar and that <m>L</m> is the language
generated by <m>G</m>.  Then there is a Turing machine, <m>M</m>, that accepts
the same language, <m>L</m>.  The alphabet for <m>M</m> will be <m>V\cup\Sigma\cup\{\text{\$,#}\}</m>,
where $ is a symbol that is not in <m>V\cup\Sigma</m>. (We also assume that # is not in <m>V\cup\Sigma</m>.)
Suppose that <m>M</m> is started with input <m>w</m>, where <m>w\in\Sigma^*</m>.
We have to design <m>M</m> so that it will halt if and only if <m>w\in L</m>.
The idea is to have <m>M</m> find each string that can be derived
from the start symbol <m>S</m>.  The strings will be written to <m>M</m>'s tape
and separated by $'s.  <m>M</m> can begin by writing the start symbol,
<m>S</m>, on its tape, separated from <m>w</m> by a $.  Then it repeats
the following process indefinitely:  For each string on the tape
and for each production rule, <m>x\PRODUCES y</m>, of <m>G</m>, search the
string for occurrences of <m>x</m>.  When one is found, add a $ to the
end of the tape and copy the string to the end of the tape, replacing
the occurrence of <m>x</m> by <m>y</m>.  The new string represents the results
of applying the production rule <m>x\PRODUCES y</m> to the string.
Each time <m>M</m> produces a new string, it compares
that string to <m>w</m>.  If they are equal, then <m>M</m> halts.  If <m>w</m> is
in fact in <m>L</m>, then eventually <m>M</m> will produce the string <m>w</m> and
will halt.  Conversely, if <m>w</m> is not in <m>L</m>, then <m>M</m> will go on producing
strings forever without ever finding <m>w</m>, so <m>M</m> will never halt.
This shows that, in fact, the language <m>L</m> is accepted by <m>M</m>.</p>

<p>
Conversely, suppose that <m>L</m> is a language over an alphabet <m>\Sigma</m>,
and that <m>L</m> is Turing-acceptable.  Then it is possible to find a grammar
<m>G</m> that generates <m>L</m>.  To do this, it's convenient to use the
fact that, as discussed above, there is a Turing-computable function
<m>f\colon \{a\}^*\to\Sigma</m> such that <m>L</m> is the range of~<m>f</m>.
Let <m>M=(Q,\Lambda,q_0,\delta)</m> be a Turing machine that computes
the function <m>f</m>.  We can build a grammar, <m>G</m>, that imitates the computations
performed by <m>M</m>.  The idea is that most of the production rules of <m>G</m> will
imitate steps in the computation of <m>M</m>.  Some additional rules (which we won't get into here) must be added
to get things started, to clean up, and to otherwise bridge the
conceptual gap between grammars and Turing machines.</p>

<!--cut out stuff here -->

<p>We have now shown, very informally, that a language
<m>L</m> is Turing-acceptable if and only if there is a grammar <m>G</m>
that generates <m>L</m>.  Even though Turing machines and grammars
are very different things, they are equivalent in terms of
their ability to describe languages.  We state this as a theorem:
</p>
<theorem xml:id="thm-turing-iff-grammar">
   <statement>
      <p>
         A language <m>L</m> is Turing acceptable (equivalently, recursively enumerable)
if and only if there is a general grammar that generates <m>L</m>.
      </p>
   </statement>
</theorem>


<p>In this section, we have been talking mostly about recursively enumerable
languages (also known as the Turing-acceptable languages).  What
about the Turing-decidable languages?  
We already know that if a language <m>L</m> is Turing-decidable,
then it is Turing-acceptable.  The converse is not true (although
we won't be able to prove this yet).  However, suppose
that <m>L</m> is a language over the alphabet <m>\Sigma</m> and that both
<m>L</m> and its complement,  <m>\bar{L}=\Sigma^* - L</m>, are Turing-acceptable.
Then <m>L</m> is Turing-decidable.</p>

<p>
For suppose that <m>M</m> is a Turing machine that accepts the language
<m>L</m> and that <m>M'</m> is a Turing machine that accepts <m>\bar{L}</m>.
We must show that <m>L</m> is Turing-decidable.  That is,
we have to build a Turing machine <m>T</m> that decides <m>L</m>. For each
<m>w\in\Sigma^*</m>, when <m>T</m> is run with input <m>w</m>, it should halt with
output 1 if <m>w\in L</m> and with output <m>0</m> if <m>w\not\in L</m>.  To do this,
<m>T</m> will simulate the computation of both <m>M</m> and <m>M'</m> on input <m>w</m>.
(It will simulate one step in the computation of <m>M</m>, then one step
in the computation of <m>M'</m>, then one step of <m>M</m>, then one step of <m>M'</m>,
and so on.)  If and when the simulated computation of <m>M</m> halts, then
<m>T</m> will halt with output~1; since <m>M</m> accepts <m>L</m>, this will happen if and
only if <m>w\in L</m>.  If and when the simulated computation of <m>M'</m> halts, then
<m>T</m> will halt with output~0; since <m>M</m> accepts <m>L</m>, this will happen if and
only if <m>w\not\in L</m>.  So, for any <m>w\in\Sigma^*</m>, <m>T</m> halts with the
desired output.  This means that <m>T</m> does in fact decide the language <m>L</m>.
</p>

<p>
It is easy to prove the converse, and the proof is left as an exercise. So
we see that a language is Turing-decidable if and only if both it and
its complement are Turing-acceptable.  Since Turing-acceptability can
be defined using other forms of computation besides Turing machines,
so can Turing-decidability.  For example, a language is Turing-decidable
if and only if both it and its complement can be generated by general grammars.
We introduced the term ``recursively enumerable''
as a synonym for Turing-acceptable, to get away from the association with a
particular form of computation.  Similarly, we define the term ``recursive''
as a synonym for Turing-decidable.  That is, a language <m>L</m>
is said to be <idx>recursive language</idx><term>recursive</term> if and only if it
is Turing-decidable.  We then have the theorem:</p>

<theorem xml:id="thm-recursive-language">
   <statement>
      <p>
         Let <m>\Sigma</m> be an alphabet and let <m>L</m> be a language over <m>\Sigma</m>.
Then <m>L</m> is recursive if and only if both <m>L</m> and its
complement, <m>\Sigma^* - L</m>, are recursively enumerable.
      </p>
   </statement>
</theorem>


</subsection>

<!-- limits  of comp section shortened from Foundations of Computation -->
<subsection xml:id="subsec-limits-of-comp">
   <title>The Limits of Computation</title> 
<idx><h>Limits of Computation</h></idx>

<p>Recursively enumerable languages are languages that can be defined by computation.
We have seen that there are many different models of computation---Turing machines,
two-tape Turing machines, grammars, computer programs---but they all lead
to the same class of languages.  In fact, every computational method for
specifying languages that has ever been developed produces only recursively
enumerable languages.  There is something about these languages---some pattern
or property---that makes them ``computable,''  and it is some intrinsic
property of the languages themselves, not some peculiarity of any given
model of computation.</p>

<p>This is especially interesting since most languages are not recursively enumerable.
Given an alphabet <m>\Sigma</m>, there are uncountably many languages over <m>\Sigma</m>, but
only countably many of them are recursively enumerable.  The rest---the vast
majority---are not recursively enumerable.  What can we say about
all these non-recursively-enumerable languages?  If the language <m>L</m> is not
recursively enumerable, then there is no algorithm for listing the members of
<m>L</m>.  It might be possible to define <m>L</m> by specifying some property that
all its members satisfy, but that property can't be computable.  That is, there
can be no computer program or Turing machine that tests whether a given
string <m>w</m> has the property, since if there were, then we could write a
program that lists the members of <m>L</m>.</p>

<p>So, even though almost every language is non-recursively-enumerable, it's
difficult to find a particular language that is not recursively enumerable.
Nevertheless, in this section we will find one such language.  At that same
time, we will find an example of a language that is recursively enumerable
but not recursive.  And we will discover some interesting limitations to
the power of computation.</p>


<p>The examples that we will look at in this section involve Turing
machines that work with other Turing machines as data.  For this to
work, we need a symbolic representation of Turing machines---a
representation that can be written on the tape of another Turing
machine.  This will let us create two machines:  First,
a Turing machine that can generate Turing machines
on demand by writing their symbolic representations on its tape.
We will design a Turing machine <m>G</m> to do this.  And second,
a Turing machine that can simulate the computation of other
Turing machines whose descriptions are written on its tape.</p>


<p>In order to do all this, we must put some limitations on
the states and alphabetic symbols that can be used in the Turing machines
that we consider.
Clearly, given any Turing machine, we can change the names of the
states without changing the behavior of the machine.  So, without any
loss of generality, we can assume that all states have names chosen
from the list: <m>h</m>, <m>q</m>, <m>q'</m>, <m>q''</m>, <m>q'''</m>, <m>q''''</m>,<m>\dots</m>.
We assume that <m>h</m> is the halt state and <m>q</m> is the start state.
Note that there is an infinite number of possible states, but any
given Turing machine will only use finitely many states from this
list.  </p>

<p>As for the alphabets of the Turing machines, I want to look at
Turing machines whose alphabets include the symbols 0, 1, <m>a</m>, and of
course #.
These are the symbols that the machines will use for input and output.
The alphabets can also include other symbols.  We will assume that
these auxiliary symbols are chosen from the list: <m>a'</m>, <m>a''</m>, <m>a'''</m>,
<m>a''''</m>,<m>\dots</m>.  Given a Turing machine whose alphabet includes
the symbols 0, 1, <m>a</m>, and #, we can rename any other symbols in its
alphabet using names from this list.  This renaming will not
affect any of the behavior that we are interested in.</p>

<p>Now suppose we have one of these standard Turing machines---one
whose states are chosen from the list <m>h</m>, <m>q</m>, <m>q'</m>, <m>q''</m>, <m>q'''</m>,<m>\dots</m>,
whose start state is <m>q</m>, and whose symbols are chosen from the list
#, 0, 1, <m>a</m>, <m>a'</m>, <m>a''</m>, <m>a'''</m>,<m>\dots</m>.  Such a machine can be
completely encoded as a string of symbols over the alphabet
<m>\{h,q,L,R,\text{\#},0,1,a,',\text{\$}\}</m>.  A transition rule
such as <m>\delta(q'',0)=(a''',L,q)</m> can be encoded as a
string <m>q''0a'''Lq</m>.  To encode a complete machine, simply encode
each of its transition rules in this way and join them together in a string,
separated by $'s.  We now have the symbolic representation for
Turing machines that we need.</p>

<p>Note that a string over the alphabet <m>\{h,q,L,R,\text{\#},0,1,a,',\text{\$}\}</m>
might or might not encode a Turing machine.  However, it is a simple
matter to check whether such a string is the code for a Turing machine.
We can imagine the following process:  Generate all the strings over the
alphabet <m>\{h,q,L,R,\text{\#},0,1,a,',\text{\$}\}</m>.  Check each string
to see whether it encodes a Turing machine.  If so, add the string
to an output list. In this way, we can generate a list of
all strings that encode standard Turing machines.  In effect,
the standard Turing machines, or at least their symbolic representations,
form a recursively enumerable set.  Let <m>T_0</m> be the
machine encoded by the first string in this list of
standard Turing machines; let <m>T_1</m> be
the machine encoded by the second string; let <m>T_2</m> be the
machine encoded by the third string; and so on.  The list
<m>T_0</m>, <m>T_1</m>, <m>T_2</m>,~\dots, includes every standard Turing machine.
Furthermore, given <m>n\in\N</m>, we can find the symbolic representation
for <m>T_n</m> by generating strings in the list until we have <m>n+1</m> strings.
Furthermore---and this is the essential point---we can use a Turing
machine to do all these calculations.  In fact, there is
a Turing machine that, when run with input <m>a^n</m>, will halt with
the string representation of <m>T_n</m> written on its tape as output.
The Turing machine that does this is <m>G</m>, the first of the
two machines that we need.</p>

<p>The second machine that we need will be called <m>U</m>.  It is a
so-called <term>Universal Turing Machine</term>.  The single Turing machine
<m>U</m> can simulate the computation of any standard Turing machine, <m>T</m>,
on any input.  Both the symbolic representation of <m>T</m> and that of
the input string are written to <m>U</m>'s tape, separated by a
space.  As <m>U</m> simulates the computation of <m>T</m>, it will need
some way to keep track of what state <m>T</m> is in and of
the position of <m>T</m> on its (simulated) tape.  It does this
by writing the current state of <m>T</m> on its tape, following
<m>T</m>'s input string, and by adding a special symbol, such as <m>@</m>,
to the input string to mark <m>T</m>'s position.  When <m>U</m> is first
started, it begins by adding the <m>@</m>to the beginning of the
input string and writing a <m>q</m> after the string to represent
the start state of <m>T</m>.  It is then relatively straightforward
for <m>U</m> to simulate the computation of <m>T</m>.  For each step
in the computation of <m>T</m>, it can determine the current state
of <m>T</m> (which is recorded on <m>U</m>'s tape) and the symbol which
<m>T</m> is currently reading (which is on <m>U</m>'s tape, after the <m>@</m>).
<m>U</m> searches the symbolic representation of <m>T</m> for the
rule that tells <m>T</m> what to do in this situation.  Using
this rule, <m>U</m> can update its representation of <m>T</m>'s state,
position, and tape to reflect the result of applying the rule.
If the new state of <m>T</m> is the halt state, then <m>U</m> also halts.
Otherwise, it goes on to simulate the next step in <m>T</m>'s computation.
Note that when <m>U</m> is given <m>T</m> and an input string <m>w</m> as
input, <m>U</m> will halt if and only if <m>T</m> halts on input <m>w</m>.
(Obviously, this is a very inefficient simulation, but we
are not concerned with efficiency here.)</p>

<p>So, we have our two machines, <m>G</m> and <m>U</m>.
After all this setup, we are finally in a position to look at
the major theorem that we have been working towards.</p>

<theorem xml:id="thm-halting-prob">
   <statement>
      <p>
         Let <m>T_0</m>, <m>T_1</m>, <m>T_2</m>, <m>\dots</m>, be the standard Turing machines,
as described above.  Let <m>K</m> be the language over the alphabet <m>\{a\}</m>
defined by 
<me>K=\{a^n\st\,T_n\text{ halts when run with input }a^n\}.</me>

Then <m>K</m> is a recursively enumerable language, but <m>K</m> is not
recursive.  The complement 
<me>\bar{K}=\{a^n\st\,T_n\text{ does
not halt when run with input }a^n\}.</me>
is a language that is not recursively enumerable.
      </p>
   </statement>
</theorem>


<p>First note that if both <m>K</m> and <m>\bar{K}</m> were recursively
enumerable, then <m>K</m> would be recursive, by <xref ref="thm-recursive-language"/>.
So, once we show that <m>K</m> is recursively enumerable but not
recursive, it follows immediately that <m>\bar{K}</m> cannot
be recursively enumerable.  That is, the second part of the
theorem follows from the first.</p>

<p>To show that <m>K</m> is recursively enumerable, it suffices to find
a Turing machine, <m>M</m>, that accepts <m>K</m>.  That is, when run
with input <m>a^n</m>, for <m>n\in\N</m>, <m>M</m> should halt if and only if
<m>a^n\in K</m>.  We can build <m>M</m> from the Turing machines <m>G</m> and <m>U</m>
which were introduced above.  When started with input <m>a^n</m>, 
<m>M</m> should proceed as follows:  
First copy the input.  Run <m>G</m> on the
first copy of <m>a^n</m>.  This will produce a symbolic description
of the Turing machine <m>T_n</m>.  Now run <m>U</m> to simulate the 
computation of <m>T_n</m> on input <m>a^n</m>.  This simulation will end
if and only if <m>T_n</m> halts when run with input <m>a^n</m>, that is, if and only
if <m>a^n\in K</m>.  The Turing machine <m>M</m> that performs the computation
we have described accepts the language <m>K</m>.
This proves that <m>K</m> is recursively enumerable.</p>

<p>To show that <m>K</m> is not recursive, we need to show that
there is <em>no</em> Turing machine that decides <m>K</m>.  
Let <m>H</m> be any Turing machine.  We must show that
no matter what <m>H</m> does, it
does not decide the language <m>K</m>.  We must do this without
knowing anything more about <m>H</m> that the fact that is it
a Turing machine.  To say that <m>H</m> decides
<m>K</m> would mean that for any <m>n\in\N</m>, when <m>H</m> is
run with input <m>a^n</m>, <m>H</m> will halt with output 1 if <m>a^n\in K</m>
and will halt with output 0 if <m>a^n\not\in K</m>.  To show that
<m>H</m> does not decide <m>K</m> we need to show that there is some
<m>n\in\N</m> such that when <m>H</m> is run with input <m>a^n</m>, 
<m>H</m> either fails to halt or else halts but gives the wrong 
output.  Note in particular that we only need to find <em>one</em>
<m>n</m> for which <m>H</m> does not give the correct result.
As we try to find <m>n</m>, we have nothing much to work with
but <m>H</m> itself.</p>

<p>To find <m>n</m>, we construct a Turing machine <m>M</m> that is a simple
variation on <m>H</m>.  When <m>M</m> is run on any input, it duplicates the behavior
of <m>H</m> on that input until <m>H</m> halts (if it ever does).  At that point, <m>M</m> should
check <m>H</m>'s output.  If <m>H</m> has halted with output <m>1</m>, then 
<m>M</m> should go into an infinite loop, so that <m>M</m> never halts in this case.
Otherwise, if the output of <m>H</m> is not <m>1</m>, then <m>M</m> should halt.
Now, we can assume that <m>M</m> is one
of the standard Turing machines, say <m>M=T_n</m>.  (If <m>M</m> is not
already one of these machines, it is because it uses different names
for its states and symbols.  Renaming the states and symbols will
produce an equivalent machine with the same behavior as <m>M</m>,
and we can replace <m>M</m> with this standard machine.) </p> 

<p>We now have a Turing machine <m>T_n = M</m> which has the following behavior
when it is run with input <m>a^n</m> (note that the <m>n</m> here is the same <m>n</m> as
in <m>T_n</m>):
If <m>H</m> halts with output 1 on input <m>a^n</m>, then <m>T_n</m>
will fail to halt on input <m>a^n</m>.  If <m>H</m> halts with output 0
on input <m>a^n</m>, then <m>T_n</m> fails to halt on input <m>a^n</m>.  (What <m>T_n</m>
might do in other cases is not relevant here.)</p>

<p>Remember that we are trying to show that <m>H</m> does not decide the language
<m>K</m>.  I claim that, in fact, <m>H</m> does not give the correct answer for <m>a^n</m>.  When <m>H</m>
is run with input <m>a^n</m>, it is supposed to halt with output 1 if <m>a^n\in K</m>,
and it is supposed to halt with output 0 if <m>a^n\not\in K</m>.  Recall that
<m>a^n\in K</m> if and only if <m>T_n</m> halts when run with input <m>a^n</m>.</p>

<p>Suppose that we run <m>H</m> with input <m>a^n</m>.
If <m>H</m> does not halt with output 0 or 1, then it has certainly not given the 
correct answer for <m>a^n</m>.  Now, suppose that <m>H</m> halts with output 1 on input <m>a^n</m>.
In this case, by the properties of <m>T_n</m> given above, we know that <m>T_n</m> does not
halt on input <m>a^n</m>.  But that means, by definition of <m>K</m>, 
that <m>a^n\not\in K</m>.  By halting with output
1 in this case, <m>H</m> has given the wrong answer for <m>a^n</m>.  Finally, suppose that
<m>H</m> halts with output 0 on input <m>a^n</m>.  We then know that <m>T_n</m> halts
on input <m>a^n</m>.  But that means that <m>a^n\in K</m>.  Again, by halting with output
0 in this case, <m>H</m> has given the wrong answer for <m>a^n</m>.  So, in no case will
<m>H</m> give the correct answer for <m>a^n</m>.  
This means that
<m>H</m> does not decide the language <m>K</m>, because <m>H</m> gives
an incorrect answer when it is run with the particular input <m>a^n</m>.
<m>H</m> does not decide <m>K</m>, and since
<m>H</m> was an arbitrary Turing machine, we see that there is
no Turing machine at all that decides the language <m>K</m>.  Thus,
<m>K</m> is not a recursive language, as the theorem claims. </p>


<p>To decide the language <m>K</m> would be to solve the following
problem:  Given a Turing machine <m>T_n</m>, decide whether or
not <m>T_n</m> will halt when it is run with input <m>a^n</m>.  This
problem is called the <term>Halting Problem</term><idx><h>Halting Problem</h></idx>.  We have shown
that there is no Turing machine that solves this problem.
Given the equivalence of Turing machines and computer programs,
we can also say that there is no computer program that
solves the halting problem.  We say that the halting problem
is <idx><h>computational unsolvability</h></idx><term>computationally unsolvable</term>.</p>

<p>The halting problem is just one
of many problems that cannot be solved by Turing machines or
computer programs.  In fact, almost any interesting yes/no
question that can be asked about Turing machines or programs
is in this class:  Does this Turing machine halt for all possible
inputs in <m>\Sigma^*</m>?  Given this input, will this program
ever halt?  Do these two programs (or Turing machines) have
the same output for each possible input?  Will this Turing
machine ever halt if it is started on a blank tape?
All these problems are computationally unsolvable in the
sense that there is no Turing machine or computer program
that will answer them correctly in all cases. The
existence of such problems is a real limitation on the
power of computation.</p>


</subsection>
<exercises xml:id="exercises-15-6">
   <title>Exercises</title>

<exercise number="1"> <p>Let <m>\Sigma=\{a\}</m>.  Draw a transition diagram for a Turing
machine that computes the function <m>f\colon\Sigma^*\to\Sigma^*</m> where
<m>f(a^n)=a^{3n}</m>, for <m>n\in\N</m>. Draw a transition diagram for a Turing
machine that computes the function <m>f\colon\Sigma^*\to\Sigma^*</m> where
<m>f(a^n)=a^{3n+1}</m>, for <m>n\in\N</m>.</p></exercise>

<exercise number="2"> <p>Let <m>\Sigma=\{a,b\}</m>.
Draw a transition diagram for a Turing machine that
computes the function <m>f\colon\Sigma^*\to\Sigma^*</m> where
<m>f(w)=w^R</m>.</p></exercise>

<exercise number="3"> <p>Suppose that <m>\Sigma</m>, <m>\Gamma</m>, and <m>\Xi</m> are alphabets and that
<m>f\colon\Sigma^*\to\Gamma^*</m> and <m>g\colon\Gamma^*\to\Xi^*</m> are 
Turing-computable functions.  Show that <m>g\circ f</m> is Turing-computable.</p></exercise>

<exercise number="4"> <p>We have defined computability for functions <m>f\colon\Sigma^*\to\Gamma^*</m>,
where <m>\Sigma</m> and <m>\Gamma</m> are alphabets.  How could Turing machines
be used to define computable functions from <m>\N</m> to <m>\N\,</m>?
(Hint: Consider the alphabet <m>\Sigma=\{a\}</m>.)</p></exercise>

<exercise number="5"> <p>Let <m>\Sigma</m> be an alphabet and let <m>L</m> be a language over <m>\Sigma</m>.
Show that <m>L</m> is Turing-decidable if and only if its complement,
<m>\bar{L}</m>, is Turing-decidable.</p></exercise>

<exercise number="6"> <p>Draw a transition diagram for a Turing machine which
decides the language <m>\{a^nb^n\st n\in\N\}</m>.  (Hint: Change the
<m>a</m>'s and <m>b</m>'s to \$'s in pairs.)  Explain in general terms how to
make a Turing machine that decides the language <m>\{a^nb^nc^n\st n\in\N\}</m>.</p></exercise>

<exercise number="7"> <p>Draw a transition diagram for a Turing machine which
decides the language <m>\{a^nb^m\st n \gt 0</m> and <m>m</m> is a multiple of <m>n\}</m>.
(Hint: Erase <m>n</m> <m>b</m>'s at a time.)</p></exercise>

<exercise number="8"> <p>Based on your answer to the previous problem and the copying
machine presented in this section, describe in
general terms how you would build a Turing machine to decide the
language <m>\{a^p\st p</m> is a prime number<m>\}</m>.</p></exercise>

<exercise number="9"><p> Let <m>g\colon \{a\}^*\to\{0,1\}^*</m> be the function such that
for each <m>n\in\N</m>, <m>g(a^n)</m> is the representation of <m>n</m> as a binary
number.  Draw a transition diagram for a Turing machine that computes <m>g</m>.</p></exercise>

<exercise number="10"><p> The language <m>L=\{a^m\st m \gt 0\}</m> is the range of the function
<m>f(a^n)=a^{n+1}</m>.  Design a Turing machine that computes this function,
and find the grammar that generates the language <m>L</m> by
imitating the computation of that machine.</p></exercise>

<exercise number="11"><p> Complete the proof of <xref ref="thm-recursive-language"/> by proving
the following:  If <m>L</m> is a recursive language over an
alphabet <m>\Sigma</m>, then both
<m>L</m> and <m>\Sigma^* -  L</m> are recursively enumerable.</p></exercise>

<exercise number="12"><p> Show that a language <m>L</m> over an alphabet <m>\Sigma</m>
is recursive if and only if there are grammars <m>G</m>
and <m>H</m> such that the language generated by <m>G</m> is <m>L</m> and the
language generated by <m>H</m> is <m>\Sigma^* -  L</m>.</p></exercise>

<exercise number="13"><p>This section discusses recursive languages and recursively
enumerable languages.  How could one define recursive subsets of
<m>\N</m> and recursively enumerable subsets of <m>\N</m>?</p></exercise>

<exercise number="14"><p> Give an informal argument to show that a subset <m>X\SUB\N</m> is
recursive if and only if there is a computer program
that prints out the elements of <m>X</m> <em>it in increasing order</em>.</p></exercise>

</exercises>
</section>
