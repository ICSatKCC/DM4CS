<?xml version="1.0" encoding="UTF-8"?>
<section xml:id="s-regular-expressions">
  <title>Regular Expressions</title>
  <idx>Regular Expressions</idx>

    <p>
      Though we have used the term <em> string</em> throughout to refer to a sequence of
symbols from an alphabet, an alternative term that is frequently used is <em>
word</em>.  The analogy seems fairly obvious: strings are made up of ``letters"
from an alphabet, just as words are in human languages like English.
In English, however, there are no particular rules specifying which sequences 
of letters can be used to form legal English words---even unlikely
combinations like <em> ghth</em> and <em> ckstr</em> have their place.  
While some formal languages may simply
be random collections of arbitrary strings, more interesting languages
are those where the strings in the language all share some 
common structure:  
<md>
<mrow>L_1 = \{ x\in \ab^* \ | n_a(x) =
n_b(x)\};</mrow>
 <mrow>L_2 = \{\mbox{legal Java identifiers}\};</mrow>
 <mrow> L_3 = \{\mbox{legal C++
programs}\}.</mrow>
</md>  
In all of these languages, there are structural 
rules which determine which sequences of symbols are in the language and which
aren't.
So
despite the terminology of ``alphabet" and ``word" in formal
language theory, the concepts don't necessarily match ``alphabet"
and ``word" for human languages.  A better parallel is to think of
the <em> alphabet</em> in a formal language as corresponding to the <em> words</em> in a
human language; the <em> words</em> in a formal language correspond to
the <em> sentences</em> in a human language, as there are rules (<em> grammar 
rules</em>) which determine how they can legally be constructed.
    </p>
    <p>
      One way of describing the grammatical structure of the strings in a language is
to use a mathematical formalism called a <term>regular expression</term>.  A regular
expression is a pattern that ``matches" strings that have a particular form.  For
example, consider the language (over alphabet <m>\Sigma = \ab</m>) <m>L= \{x \ | \ x
\mbox{ starts and ends with } a\}</m>.  What is the symbol-by-symbol 
structure of
strings in this language?  Well, they start with an <m>a</m>, followed by zero or more
<m>a</m>'s or <m>b</m>'s or both, followed by an <m>a</m>.  The regular expression 
<m>a \cdot (a \REOR b)^* \cdot a</m> is a pattern that captures this structure and matches any string in
<m>L</m> (<m>\cdot</m> and <m>^*</m> have their usual meanings, and <m>\REOR</m>  designates <em>or</em>.)
<aside>
  <p>
  Various
symbols have been used to represent the ``or'' operation in regular expressions.  Both
<m>+</m> and <m>\cup</m> have been used for this purpose.  In this book, we use the symbol <m>|</m> because
it is commonly used in computer implementations of regular expressions.
  </p>
</aside> 
Conversely, consider the regular expression <m>(a\cdot(a\REOR b)^*) \REOR  ((a\REOR b)^*\cdot a)</m>.
This is a pattern that matches any string that either has the form ``<m>a</m> followed
by zero or more <m>a</m>'s or <m>b</m>'s or both" (i.e. any string that starts with an <m>a</m>)
<em>or</em> has the form ``zero or more <m>a</m>'s or <m>b</m>'s or both followed by an <m>a</m>"
(i.e. any string that ends with an <m>a</m>).  Thus the regular expression 
<em>generates</em> the language of all strings that start or end (or both) in an
<m>a</m>: this is the set of strings that match the regular expression. 
</p>
<p>
Here are the formal definitions of a regular expression and the language
generated by a regular expression:
    </p>
 
  
   <definition
            xml:id="def-regex">
            <title>Regular Expression</title>
            <idx>Regular Expression</idx>
            <notation>
                <usage>
                    <m>\Phi</m>
                </usage>
                <description>A regular expression.</description>
            </notation>
            <statement>
                <p> Let <m>\Sigma</m> be an alphabet.  Then the 
following patterns are <em>regular expressions</em> over <m>\Sigma</m>:
<ol>
  <li>
    <p>
       <m>\Phi</m> and <m>\varep</m> are regular expressions;
    </p>
  </li>
  <li>
    <p>
      <m>a</m> is a regular expression, for each <m>a \in \Sigma</m>;
    </p>
  </li>
  <li>
    <p>
      if <m>r_1</m> and <m>r_2</m> are regular expressions, then so are
<m>r_1\REOR r_2</m>, <m>r_1\cdot r_2</m>, <m>r_1^*</m> and <m>(r_1)</m> (and of course, <m>r_2^*</m>
and <m>(r_2)</m>).
As in concatenation of strings, the <m>\cdot</m> is often left out of
the second expression.  (Note: the order of precedence of operators, from lowest to highest,
is <m>\REOR</m> , <m>\cdot</m>, <m>*</m>.)
    </p>
  </li>
</ol>


</p>
<p>
  No other patterns are regular expressions.
</p>
            </statement>
        </definition>
       <definition
            xml:id="def-language-gen-by-regex">
            <title>Language Generated by a Regular Expression</title>
            <idx>Language Generated by a Regular Expression</idx>
            <notation>
                <usage>
                    <m>L(r)</m> 
                </usage>
                <description>A language generated by regular expression <m>r</m>.</description>
            </notation>
            <statement>
                <p>The <term>language generated by a regular expression</term> <m>r</m>, 
denoted <m>L(r)</m>,
is defined as follows:
<ol>
  <li>
    <p>
       <m>L(\Phi) = \emptyset, i.e.\ no strings match \Phi</m>;
    </p>
  </li>
  <li>
    <p>
     <m>L(\varep) = \{\varep\}</m>, i.e.\ <m>\varep</m> matches only the 
empty string;
    </p>
  </li>
  <li>
    <p>
    <m>L(a) = \{a\}</m>, i.e.\ <m>a</m> matches only the string <m>a</m>;
    </p>
  </li>
  <li>
    <p>
      <m>L(r_1\REOR r_2) = L(r_1) \cup L(r_2)</m>, i.e.\ <m>r_1\REOR r_2</m> matches
strings that match <m>r_1</m> or <m>r_2</m> or both;
    </p>
  </li>
  <li>
    <p>
      <m>L(r_1r_2) = L(r_1)L(r_2)</m>, i.e.\ <m>r_1r_2</m> matches strings of the form 
``something that matches <m>r_1</m> followed by something that 
matches <m>r_2</m>";
    </p>
  </li>
  <li>
    <p>
      <m>L(r_1^*) = (L(r_1))^*</m>, i.e.\ <m>r_1^*</m> matches sequences of 0
or more strings each of which matches <m>r_1</m>.
    </p>
  </li>
  <li>
    <p>
      <m>L((r_1)) = L(r_1)</m>, i.e.\ <m>(r_1)</m> matches exactly those strings
matched by <m>r_1</m>.
    </p>
  </li>
</ol>
</p>
            </statement>
        </definition>  
</section>
